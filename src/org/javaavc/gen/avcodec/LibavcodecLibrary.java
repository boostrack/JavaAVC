package org.javaavc.gen.avcodec;
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
/**
 * JNA Wrapper for library <b>Libavcodec</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface LibavcodecLibrary extends Library {
    /**
     * @ingroup lavc_encoding<br>
     * motion estimation type.<br>
     * enum values
     */
    public static interface Motion_Est_ID {
        /** < no search, that is use 0,0 vector whenever one is needed */
        public static final int ME_ZERO = 1;
        public static final int ME_FULL = 2;
        public static final int ME_LOG = 3;
        public static final int ME_PHODS = 4;
        /** < enhanced predictive zonal search */
        public static final int ME_EPZS = 5;
        /** < reserved for experiments */
        public static final int ME_X1 = 6;
        /** < hexagon based search */
        public static final int ME_HEX = 7;
        /** < uneven multi-hexagon search */
        public static final int ME_UMH = 8;
        /** < iterative search */
        public static final int ME_ITER = 9;
        /** < transformed exhaustive search algorithm */
        public static final int ME_TESA = 10;
    };
    /**
     * @ingroup lavc_decoding<br>
     * enum values
     */
    public static interface AVDiscard {
        /**
         * We leave some space between them for extensions (drop some<br>
         * keyframes for intra-only or drop just some bidir frames).<br>
         * < discard nothing
         */
        public static final int AVDISCARD_NONE = -16;
        /** < discard useless packets like 0 size packets in avi */
        public static final int AVDISCARD_DEFAULT = 0;
        /** < discard all non reference */
        public static final int AVDISCARD_NONREF = 8;
        /** < discard all bidirectional frames */
        public static final int AVDISCARD_BIDIR = 16;
        /** < discard all frames except keyframes */
        public static final int AVDISCARD_NONKEY = 32;
        /** < discard all */
        public static final int AVDISCARD_ALL = 48;
    };
    /** enum values */
    public static interface AVColorPrimaries {
        /** < also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B */
        public static final int AVCOL_PRI_BT709 = 1;
        public static final int AVCOL_PRI_UNSPECIFIED = 2;
        public static final int AVCOL_PRI_BT470M = 4;
        /** < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM */
        public static final int AVCOL_PRI_BT470BG = 5;
        /** < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC */
        public static final int AVCOL_PRI_SMPTE170M = 6;
        /** < functionally identical to above */
        public static final int AVCOL_PRI_SMPTE240M = 7;
        public static final int AVCOL_PRI_FILM = 8;
        /** < Not part of ABI */
        public static final int AVCOL_PRI_NB = 9;
    };
    /** enum values */
    public static interface AVColorTransferCharacteristic {
        /** < also ITU-R BT1361 */
        public static final int AVCOL_TRC_BT709 = 1;
        public static final int AVCOL_TRC_UNSPECIFIED = 2;
        /** < also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM */
        public static final int AVCOL_TRC_GAMMA22 = 4;
        /** < also ITU-R BT470BG */
        public static final int AVCOL_TRC_GAMMA28 = 5;
        public static final int AVCOL_TRC_SMPTE240M = 7;
        /** < Not part of ABI */
        public static final int AVCOL_TRC_NB = 8;
    };
    /** enum values */
    public static interface AVColorSpace {
        public static final int AVCOL_SPC_RGB = 0;
        /** < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B */
        public static final int AVCOL_SPC_BT709 = 1;
        public static final int AVCOL_SPC_UNSPECIFIED = 2;
        public static final int AVCOL_SPC_FCC = 4;
        /** < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601 */
        public static final int AVCOL_SPC_BT470BG = 5;
        /** < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above */
        public static final int AVCOL_SPC_SMPTE170M = 6;
        public static final int AVCOL_SPC_SMPTE240M = 7;
        /** < Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16 */
        public static final int AVCOL_SPC_YCOCG = 8;
        /** < Not part of ABI */
        public static final int AVCOL_SPC_NB = 9;
    };
    /** enum values */
    public static interface AVColorRange {
        public static final int AVCOL_RANGE_UNSPECIFIED = 0;
        /** < the normal 219*2^(n-8) "MPEG" YUV ranges */
        public static final int AVCOL_RANGE_MPEG = 1;
        /** < the normal     2^n-1   "JPEG" YUV ranges */
        public static final int AVCOL_RANGE_JPEG = 2;
        /** < Not part of ABI */
        public static final int AVCOL_RANGE_NB = 3;
    };
    /**
     * X   X      3 4 X      X are luma samples,<br>
     *             1 2        1-6 are possible chroma positions<br>
     *  X   X      5 6 X      0 is undefined/unknown position<br>
     * enum values
     */
    public static interface AVChromaLocation {
        public static final int AVCHROMA_LOC_UNSPECIFIED = 0;
        /** < mpeg2/4, h264 default */
        public static final int AVCHROMA_LOC_LEFT = 1;
        /** < mpeg1, jpeg, h263 */
        public static final int AVCHROMA_LOC_CENTER = 2;
        /** < DV */
        public static final int AVCHROMA_LOC_TOPLEFT = 3;
        public static final int AVCHROMA_LOC_TOP = 4;
        public static final int AVCHROMA_LOC_BOTTOMLEFT = 5;
        public static final int AVCHROMA_LOC_BOTTOM = 6;
        /** < Not part of ABI */
        public static final int AVCHROMA_LOC_NB = 7;
    };
    /** enum values */
    public static interface AVAudioServiceType {
        public static final int AV_AUDIO_SERVICE_TYPE_MAIN = 0;
        public static final int AV_AUDIO_SERVICE_TYPE_EFFECTS = 1;
        public static final int AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2;
        public static final int AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3;
        public static final int AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4;
        public static final int AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5;
        public static final int AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6;
        public static final int AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7;
        public static final int AV_AUDIO_SERVICE_TYPE_KARAOKE = 8;
        /** < Not part of ABI */
        public static final int AV_AUDIO_SERVICE_TYPE_NB = 9;
    };
    /**
     * @defgroup lavc_packet AVPacket<br>
     * * Types and functions for working with AVPacket.<br>
     * @{<br>
     * enum values
     */
    public static interface AVPacketSideDataType {
        public static final int AV_PKT_DATA_PALETTE = 0;
        public static final int AV_PKT_DATA_NEW_EXTRADATA = 1;
        /**
         * An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:<br>
         * @code<br>
         * u32le param_flags<br>
         * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)<br>
         *     s32le channel_count<br>
         * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)<br>
         *     u64le channel_layout<br>
         * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)<br>
         *     s32le sample_rate<br>
         * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)<br>
         *     s32le width<br>
         *     s32le height<br>
         * @endcode
         */
        public static final int AV_PKT_DATA_PARAM_CHANGE = 2;
        /**
         * An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of<br>
         * structures with info about macroblocks relevant to splitting the<br>
         * packet into smaller packets on macroblock edges (e.g. as for RFC 2190).<br>
         * That is, it does not necessarily contain info about all macroblocks,<br>
         * as long as the distance between macroblocks in the info is smaller<br>
         * than the target payload size.<br>
         * Each MB info structure is 12 bytes, and is laid out as follows:<br>
         * @code<br>
         * u32le bit offset from the start of the packet<br>
         * u8    current quantizer at the start of the macroblock<br>
         * u8    GOB number<br>
         * u16le macroblock address within the GOB<br>
         * u8    horizontal MV predictor<br>
         * u8    vertical MV predictor<br>
         * u8    horizontal MV predictor for block number 3<br>
         * u8    vertical MV predictor for block number 3<br>
         * @endcode
         */
        public static final int AV_PKT_DATA_H263_MB_INFO = 3;
        /**
         * Recommmends skipping the specified number of samples<br>
         * @code<br>
         * u32le number of samples to skip from start of this packet<br>
         * u32le number of samples to skip from end of this packet<br>
         * u8    reason for start skip<br>
         * u8    reason for end   skip (0=padding silence, 1=convergence)<br>
         * @endcode
         */
        public static final int AV_PKT_DATA_SKIP_SAMPLES = 70;
        /**
         * An AV_PKT_DATA_JP_DUALMONO side data packet indicates that<br>
         * the packet may contain "dual mono" audio specific to Japanese DTV<br>
         * and if it is true, recommends only the selected channel to be used.<br>
         * @code<br>
         * u8    selected channels (0=mail/left, 1=sub/right, 2=both)<br>
         * @endcode
         */
        public static final int AV_PKT_DATA_JP_DUALMONO = 71;
        /**
         * A list of zero terminated key/value strings. There is no end marker for<br>
         * the list, so it is required to rely on the side data size to stop.
         */
        public static final int AV_PKT_DATA_STRINGS_METADATA = 72;
        /**
         * Subtitle event position<br>
         * @code<br>
         * u32le x1<br>
         * u32le y1<br>
         * u32le x2<br>
         * u32le y2<br>
         * @endcode
         */
        public static final int AV_PKT_DATA_SUBTITLE_POSITION = 73;
        /**
         * Data found in BlockAdditional element of matroska container. There is<br>
         * no end marker for the data, so it is required to rely on the side data<br>
         * size to recognize the end. 8 byte id (as found in BlockAddId) followed<br>
         * by data.
         */
        public static final int AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 74;
    };
    /** enum values */
    public static interface AVSideDataParamChangeFlags {
        public static final int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 0x0001;
        public static final int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002;
        public static final int AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 0x0004;
        public static final int AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 0x0008;
    };
    /** enum values */
    public static interface AVFieldOrder {
        public static final int AV_FIELD_UNKNOWN = 0;
        public static final int AV_FIELD_PROGRESSIVE = 1;
        /** < Top coded_first, top displayed first */
        public static final int AV_FIELD_TT = 2;
        /** < Bottom coded first, bottom displayed first */
        public static final int AV_FIELD_BB = 3;
        /** < Top coded first, bottom displayed first */
        public static final int AV_FIELD_TB = 4;
        /** < Bottom coded first, top displayed first */
        public static final int AV_FIELD_BT = 5;
    };
    /** enum values */
    public static interface AVSubtitleType {
        public static final int SUBTITLE_NONE = 0;
        /** < A bitmap, pict will be set */
        public static final int SUBTITLE_BITMAP = 1;
        /**
         * Plain text, the text field must be set by the decoder and is<br>
         * authoritative. ass and pict fields may contain approximations.
         */
        public static final int SUBTITLE_TEXT = 2;
        /**
         * Formatted text, the ass field must be set by the decoder and is<br>
         * authoritative. pict and text fields may contain approximations.
         */
        public static final int SUBTITLE_ASS = 3;
    };
    /**
     * Lock operation used by lockmgr<br>
     * enum values
     */
    public static interface AVLockOp {
        /** < Create a mutex */
        public static final int AV_LOCK_CREATE = 0;
        /** < Lock the mutex */
        public static final int AV_LOCK_OBTAIN = 1;
        /** < Unlock the mutex */
        public static final int AV_LOCK_RELEASE = 2;
        /** < Free mutex resources */
        public static final int AV_LOCK_DESTROY = 3;
    };
    public static final int CODEC_FLAG_CLOSED_GOP = 0x80000000;
    public static final int CODEC_FLAG2_STRICT_GOP = 0x00000002;
    public static final int FF_IDCT_ALTIVEC = 8;
    public static final int FF_CMP_CHROMA = 256;
    public static final int FF_PROFILE_VC1_MAIN = 1;
    public static final int FF_PROFILE_MPEG2_SS = 2;
    public static final int FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = 9;
    public static final int FF_DEBUG_BUFFERS = 0x00008000;
    public static final int CODEC_FLAG_CBP_RD = 0x04000000;
    public static final int FF_DEBUG_BUGS = 0x00001000;
    public static final int FF_BUG_AMV = 32;
    public static final int AV_EF_EXPLODE = (1 << 3);
    public static final int FF_DEBUG_ER = 0x00000400;
    public static final int FF_SUB_CHARENC_MODE_PRE_DECODER = 1;
    public static final int CODEC_FLAG_GRAY = 0x2000;
    public static final int MB_TYPE_16x8 = 0x0010;
    public static final int FF_CODER_TYPE_RLE = 3;
    public static final int FF_MB_DECISION_BITS = 1;
    public static final int FF_CODER_TYPE_VLC = 0;
    public static final int FF_BUG_QPEL_CHROMA2 = 256;
    public static final int CODEC_FLAG_EMU_EDGE = 0x4000;
    public static final int FF_DECODE_ERROR_INVALID_BITSTREAM = 1;
    public static final int FF_MB_DECISION_SIMPLE = 0;
    public static final boolean FF_API_MMI = (54 < 55);
    public static final int FF_PROFILE_MPEG4_CORE_SCALABLE = 10;
    public static final int CODEC_FLAG2_IGNORE_CROP = 0x00010000;
    public static final int LIBAVCODEC_VERSION_INT = (54 << 16 | 92 << 8 | 100);
    public static final int FF_COMPLIANCE_VERY_STRICT = 2;
    public static final int AV_NUM_DATA_POINTERS = 8;
    public static final int FF_BUFFER_TYPE_INTERNAL = 1;
    public static final int FF_DTG_AFD_16_9_SP_14_9 = 14;
    public static final int MB_TYPE_P0L1 = 0x4000;
    public static final int MB_TYPE_8x16 = 0x0020;
    public static final int FF_PROFILE_H264_HIGH_444 = 144;
    public static final int FF_PROFILE_H264_HIGH = 100;
    public static final int CODEC_FLAG2_SHOW_ALL = 0x00400000;
    public static final int SLICE_FLAG_ALLOW_PLANE = 0x0004;
    public static final int FF_PROFILE_DTS_HD_HRA = 50;
    public static final int FF_LOSS_RESOLUTION = 0x0001;
    public static final int CODEC_FLAG_TRUNCATED = 0x00010000;
    public static final int FF_CMP_SSE = 1;
    public static final int FF_DEBUG_STARTCODE = 0x00000100;
    public static final int FF_BUFFER_HINTS_PRESERVE = 0x04;
    public static final int FF_CMP_PSNR = 4;
    public static final int FF_PROFILE_DTS = 20;
    public static final int FF_PROFILE_H264_HIGH_444_INTRA = (244 | (1 << 11));
    public static final int AV_CODEC_PROP_LOSSY = (1 << 1);
    public static final int FF_PROFILE_H264_HIGH_422 = 122;
    public static final int FF_PROFILE_MPEG4_SIMPLE_STUDIO = 14;
    public static final int CODEC_CAP_INTRA_ONLY = 0x40000000;
    public static final int FF_LEVEL_UNKNOWN = -99;
    public static final int CODEC_CAP_FRAME_THREADS = 0x1000;
    public static final int FF_DTG_AFD_14_9 = 11;
    public static final int CODEC_FLAG2_NO_OUTPUT = 0x00000004;
    public static final int CODEC_FLAG_BITEXACT = 0x00800000;
    public static final int FF_IDCT_SH4 = 9;
    public static final int FF_LOSS_CHROMA = 0x0020;
    public static final int FF_PROFILE_DTS_ES = 30;
    public static final int FF_IDCT_INT = 1;
    public static final int FF_INPUT_BUFFER_PADDING_SIZE = 16;
    public static final int FF_THREAD_FRAME = 1;
    public static final int FF_DTG_AFD_16_9 = 10;
    public static final int CODEC_CAP_VARIABLE_FRAME_SIZE = 0x10000;
    public static final int FF_IDCT_AUTO = 0;
    public static final int CODEC_FLAG_INTERLACED_DCT = 0x00040000;
    public static final int CODEC_CAP_CHANNEL_CONF = 0x0400;
    public static final int CODEC_FLAG_LOW_DELAY = 0x00080000;
    public static final int FF_DEBUG_MV = 32;
    public static final int AV_EF_AGGRESSIVE = (1 << 18);
    public static final int MB_TYPE_P0L0 = 0x1000;
    public static final int FF_PROFILE_DTS_96_24 = 40;
    public static final int CODEC_FLAG_INTERLACED_ME = 0x20000000;
    public static final boolean FF_API_OLD_DECODE_AUDIO = (54 < 55);
    public static final int CODEC_FLAG_PASS2 = 0x0400;
    public static final int CODEC_FLAG_PASS1 = 0x0200;
    public static final int AV_EF_CAREFUL = (1 << 16);
    public static final int FF_PROFILE_DTS_HD_MA = 60;
    public static final int FF_THREAD_SLICE = 2;
    public static final int FF_LOSS_DEPTH = 0x0002;
    public static final int FF_IDCT_SIMPLEMMX = 3;
    public static final int FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13;
    public static final int FF_PRED_PLANE = 1;
    public static final int FF_IDCT_MMI = 5;
    public static final int FF_DEBUG_VIS_MB_TYPE = 0x00004000;
    public static final int FF_IDCT_EA = 21;
    public static final int FF_CMP_VSSE = 9;
    public static final int FF_IDCT_SIMPLEARMV5TE = 16;
    public static final int FF_CMP_NSSE = 10;
    public static final int FF_DEBUG_QP = 16;
    public static final int FF_QSCALE_TYPE_MPEG1 = 0;
    public static final int FF_QSCALE_TYPE_MPEG2 = 1;
    public static final int FF_IDCT_ARM = 7;
    public static final int FF_DEBUG_RC = 2;
    public static final int FF_IDCT_IPP = 13;
    public static final int FF_DCT_MMX = 3;
    public static final int PARSER_FLAG_COMPLETE_FRAMES = 0x0001;
    public static final int FF_PROFILE_MPEG2_422 = 0;
    public static final int FF_IDCT_XVIDMMX = 14;
    public static final int MB_TYPE_QUANT = 0x00010000;
    public static final int AV_EF_BITSTREAM = (1 << 1);
    public static final int FF_CMP_SATD = 2;
    public static final boolean FF_API_OLD_ENCODE_VIDEO = (54 < 55);
    public static final int FF_CMP_RD = 6;
    public static final int FF_PROFILE_MPEG2_SNR_SCALABLE = 3;
    public static final int CODEC_CAP_DRAW_HORIZ_BAND = 0x0001;
    public static final int FF_DEBUG_DCT_COEFF = 0x00000040;
    public static final boolean FF_API_LIBMPEG2 = (54 < 55);
    public static final boolean FF_API_DEINTERLACE = (54 < 56);
    public static final int FF_CMP_SAD = 0;
    public static final int FF_BUG_TRUNCATED = 16384;
    public static final int CODEC_FLAG2_SKIP_RD = 0x00004000;
    public static final int FF_BUG_XVID_ILACE = 4;
    public static final int FF_IDCT_CAVS = 15;
    public static final int FF_LOSS_COLORQUANT = 0x0010;
    public static final int FF_CODER_TYPE_RAW = 2;
    public static final int SLICE_FLAG_ALLOW_FIELD = 0x0002;
    public static final int FF_DEBUG_THREADS = 0x00010000;
    public static final int FF_BUFFER_HINTS_REUSABLE = 0x08;
    public static final int FF_PROFILE_H264_HIGH_444_PREDICTIVE = 244;
    public static final int FF_DEBUG_MB_TYPE = 8;
    public static final int FF_DCT_AUTO = 0;
    public static final int FF_PROFILE_MPEG4_HYBRID = 8;
    public static final int FF_RC_STRATEGY_XVID = 1;
    public static final int MB_TYPE_INTRA4x4 = 0x0001;
    public static final int FF_CODER_TYPE_DEFLATE = 4;
    public static final int FF_PROFILE_AAC_LTP = 3;
    public static final int MB_TYPE_CBP = 0x00020000;
    public static final int FF_IDCT_SIMPLEVIS = 18;
    public static final int CODEC_CAP_LOSSLESS = 0x80000000;
    public static final boolean FF_API_CODEC_ID = (54 < 55);
    public static final int CODEC_CAP_NEG_LINESIZES = 0x0800;
    public static final int AV_EF_BUFFER = (1 << 2);
    public static final int CODEC_CAP_TRUNCATED = 0x0008;
    public static final int FF_PROFILE_MPEG4_ADVANCED_SIMPLE = 15;
    public static final boolean FF_API_AVCODEC_RESAMPLE = (54 < 55);
    public static final int AV_PARSER_PTS_NB = 4;
    public static final int FF_QSCALE_TYPE_VP56 = 3;
    public static final int FF_LOSS_ALPHA = 0x0008;
    public static final int FF_PROFILE_MPEG4_N_BIT = 4;
    public static final int FF_DEFAULT_QUANT_BIAS = 999999;
    public static final int FF_PROFILE_MPEG2_MAIN = 4;
    public static final int AV_CODEC_PROP_LOSSLESS = (1 << 2);
    public static final int FF_PROFILE_AAC_LOW = 1;
    public static final int FF_PROFILE_H264_BASELINE = 66;
    public static final int MB_TYPE_GMC = 0x0400;
    public static final int CODEC_CAP_AUTO_THREADS = 0x8000;
    public static final int CODEC_CAP_SUBFRAMES = 0x0100;
    public static final int AVCODEC_MAX_AUDIO_FRAME_SIZE = 192000;
    public static final int PARSER_FLAG_ONCE = 0x0002;
    public static final int CODEC_FLAG_4MV = 0x0004;
    public static final boolean FF_API_FIND_BEST_PIX_FMT = (54 < 55);
    public static final int CODEC_FLAG2_LOCAL_HEADER = 0x00000008;
    public static final int CODEC_CAP_EXPERIMENTAL = 0x0200;
    public static final boolean FF_API_MPV_GLOBAL_OPTS = (54 < 55);
    public static final int FF_BUG_OLD_MSMPEG4 = 2;
    public static final int FF_DEBUG_PICT_INFO = 1;
    public static final int FF_DCT_INT = 2;
    public static final int FF_IDCT_SIMPLENEON = 22;
    public static final int FF_DEBUG_VIS_MV_B_BACK = 0x00000004;
    public static final int CODEC_FLAG_NORMALIZE_AQP = 0x00020000;
    public static final int FF_PROFILE_MPEG2_SIMPLE = 5;
    public static final int FF_ASPECT_EXTENDED = 15;
    public static final int FF_MAX_B_FRAMES = 16;
    public static final int FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = 6;
    public static final int LIBAVCODEC_VERSION_MINOR = 92;
    public static final int FF_MIN_BUFFER_SIZE = 16384;
    public static final int FF_MB_DECISION_RD = 2;
    public static final int FF_BUG_DC_CLIP = 4096;
    public static final int FF_CMP_W97 = 12;
    public static final int FF_PROFILE_AAC_LD = 22;
    public static final int FF_IDCT_SIMPLEARMV6 = 17;
    public static final int MB_TYPE_8x8 = 0x0040;
    public static final int FF_CODER_TYPE_AC = 1;
    public static final int FF_PROFILE_H264_CAVLC_444 = 44;
    public static final int FF_PROFILE_MPEG4_CORE = 2;
    public static final int SLICE_FLAG_CODED_ORDER = 0x0001;
    public static final int MB_TYPE_P1L1 = 0x8000;
    public static final int AV_EF_COMPLIANT = (1 << 17);
    public static final int MB_TYPE_P1L0 = 0x2000;
    public static final int FF_PROFILE_VC1_SIMPLE = 0;
    public static final int FF_PROFILE_VC1_ADVANCED = 3;
    public static final int CODEC_CAP_DR1 = 0x0002;
    public static final int FF_PROFILE_H264_HIGH_10 = 110;
    public static final String LIBAVCODEC_IDENT = "Lavc";
    public static final boolean FF_API_SUB_ID = (54 < 55);
    public static final int FF_IDCT_BINK = 24;
    public static final int CODEC_FLAG_MV0 = 0x0040;
    public static final int MB_TYPE_INTERLACED = 0x0080;
    public static final int FF_PROFILE_MPEG4_ADVANCED_CODING = 11;
    public static final int FF_BUG_QPEL_CHROMA = 64;
    public static final boolean FF_API_IDCT = (54 < 55);
    public static final int FF_COMPLIANCE_UNOFFICIAL = -1;
    public static final int FF_DEBUG_VIS_MV_B_FOR = 0x00000002;
    public static final int PARSER_FLAG_FETCHED_OFFSET = 0x0004;
    public static final int FF_CMP_W53 = 11;
    public static final int FF_PROFILE_AAC_HE = 4;
    public static final int FF_SUB_CHARENC_MODE_AUTOMATIC = 0;
    public static final int FF_PROFILE_H264_HIGH_422_INTRA = (122 | (1 << 11));
    public static final int AV_PKT_FLAG_KEY = 0x0001;
    public static final int FF_BUG_STD_QPEL = 128;
    public static final int FF_DTG_AFD_SP_4_3 = 15;
    public static final int FF_DEBUG_MMCO = 0x00000800;
    public static final int FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = 7;
    public static final int FF_IDCT_WMV2 = 19;
    public static final int FF_DECODE_ERROR_MISSING_REFERENCE = 2;
    public static final int AV_CODEC_PROP_INTRA_ONLY = (1 << 0);
    public static final int FF_COMPLIANCE_STRICT = 1;
    public static final boolean FF_API_INTER_THRESHOLD = (54 < 55);
    public static final int MB_TYPE_L0L1 = ((0x1000 | 0x2000) | (0x4000 | 0x8000));
    public static final int FF_BUG_HPEL_CHROMA = 2048;
    public static final int MB_TYPE_INTRA16x16 = 0x0002;
    public static final boolean FF_API_OLD_TIMECODE = (54 < 55);
    public static final int FF_DEBUG_VIS_QP = 0x00002000;
    public static final int FF_DEBUG_BITSTREAM = 4;
    public static final int FF_CMP_DCT264 = 14;
    public static final int FF_EC_DEBLOCK = 2;
    public static final int FF_PROFILE_RESERVED = -100;
    public static final int MB_TYPE_16x16 = 0x0008;
    public static final int FF_PROFILE_AAC_MAIN = 0;
    public static final int FF_BUG_EDGE = 1024;
    public static final int FF_IDCT_VP3 = 12;
    public static final int CODEC_CAP_HWACCEL_VDPAU = 0x0080;
    public static final int FF_DTG_AFD_SAME = 8;
    public static final int CODEC_FLAG2_FAST = 0x00000001;
    public static final int FF_BUFFER_TYPE_USER = 2;
    public static final int CODEC_FLAG2_CHUNKS = 0x00008000;
    public static final int AV_PKT_FLAG_CORRUPT = 0x0002;
    public static final int FF_IDCT_SIMPLEALPHA = 23;
    public static final int FF_BUG_MS = 8192;
    public static final int FF_PROFILE_AAC_HE_V2 = 28;
    public static final int CODEC_FLAG_QSCALE = 0x0002;
    public static final int FF_PROFILE_MPEG4_SIMPLE_SCALABLE = 1;
    public static final int MB_TYPE_ACPRED = 0x0200;
    public static final int CODEC_FLAG_QP_RD = 0x08000000;
    public static final int FF_IDCT_FAAN = 20;
    public static final int FF_PROFILE_H264_INTRA = (1 << 11);
    public static final int FF_BUFFER_TYPE_COPY = 8;
    public static final int FF_BUFFER_HINTS_VALID = 0x01;
    public static final int MB_TYPE_DIRECT2 = 0x0100;
    public static final boolean FF_API_AVCODEC_OPEN = (54 < 55);
    public static final int FF_PRED_LEFT = 0;
    public static final int CODEC_FLAG_INPUT_PRESERVED = 0x0100;
    public static final int FF_COMPRESSION_DEFAULT = -1;
    public static final int FF_PROFILE_MPEG2_HIGH = 1;
    public static final int FF_BUFFER_HINTS_READABLE = 0x02;
    public static final boolean FF_API_OLD_ENCODE_AUDIO = (54 < 55);
    public static final int FF_PROFILE_H264_EXTENDED = 88;
    public static final int CODEC_FLAG_QPEL = 0x0010;
    public static final int FF_IDCT_LIBMPEG2MMX = 4;
    public static final int FF_COMPLIANCE_NORMAL = 0;
    public static final int MB_TYPE_L0 = (0x1000 | 0x2000);
    public static final int CODEC_CAP_HWACCEL = 0x0010;
    public static final int MB_TYPE_L1 = (0x4000 | 0x8000);
    public static final boolean FF_API_COLOR_TABLE_ID = (54 < 55);
    public static final int FF_PROFILE_H264_MAIN = 77;
    public static final int FF_BUFFER_TYPE_SHARED = 4;
    public static final int CODEC_CAP_DELAY = 0x0020;
    public static final int FF_PROFILE_MPEG4_SCALABLE_TEXTURE = 5;
    public static final int FF_BUG_AUTODETECT = 1;
    public static final int FF_PROFILE_VC1_COMPLEX = 2;
    public static final int FF_COMPLIANCE_EXPERIMENTAL = -2;
    public static final int FF_DEBUG_VIS_MV_P_FOR = 0x00000001;
    public static final int FF_CMP_DCT = 3;
    public static final int FF_IDCT_SIMPLEARM = 10;
    public static final int FF_PROFILE_MPEG4_SIMPLE = 0;
    public static final int LIBAVCODEC_BUILD = (54 << 16 | 92 << 8 | 100);
    public static final int FF_SUB_CHARENC_MODE_DO_NOTHING = -1;
    public static final int FF_PROFILE_MPEG4_MAIN = 3;
    public static final int FF_PROFILE_AAC_SSR = 2;
    public static final int CODEC_FLAG_GLOBAL_HEADER = 0x00400000;
    public static final int LIBAVCODEC_VERSION_MAJOR = 54;
    public static final int CODEC_FLAG_PSNR = 0x8000;
    public static final int CODEC_CAP_SMALL_LAST_FRAME = 0x0040;
    public static final int AV_SUBTITLE_FLAG_FORCED = 0x00000001;
    public static final int MB_TYPE_SKIP = 0x0800;
    public static final int FF_PROFILE_H264_HIGH_10_INTRA = (110 | (1 << 11));
    public static final int FF_LOSS_COLORSPACE = 0x0004;
    public static final int AV_EF_CRCCHECK = (1 << 0);
    public static final int FF_DCT_FAAN = 6;
    public static final int FF_IDCT_H264 = 11;
    public static final int FF_QSCALE_TYPE_H264 = 2;
    public static final int FF_DEBUG_SKIP = 0x00000080;
    public static final int FF_PROFILE_H264_CONSTRAINED_BASELINE = (66 | (1 << 9));
    public static final int FF_DTG_AFD_4_3_SP_14_9 = 13;
    public static final int FF_DCT_ALTIVEC = 5;
    public static final int FF_CMP_BIT = 5;
    public static final int FF_BUG_AC_VLC = 0;
    public static final int FF_DEBUG_PTS = 0x00000200;
    public static final int AV_CODEC_PROP_BITMAP_SUB = (1 << 16);
    public static final int FF_DTG_AFD_4_3 = 9;
    public static final int FF_BUG_NO_PADDING = 16;
    public static final int CODEC_FLAG_LOOP_FILTER = 0x00000800;
    public static final int FF_CMP_DCTMAX = 13;
    public static final int FF_IDCT_SIMPLE = 2;
    public static final int FF_PROFILE_UNKNOWN = -99;
    public static final int FF_CMP_VSAD = 8;
    public static final int CODEC_CAP_SLICE_THREADS = 0x2000;
    public static final int CODEC_CAP_PARAM_CHANGE = 0x4000;
    public static final boolean FF_API_ALLOC_CONTEXT = (54 < 55);
    public static final boolean FF_API_DSP_MASK = (54 < 55);
    public static final int FF_PROFILE_MPEG4_ADVANCED_CORE = 12;
    public static final int MB_TYPE_INTRA_PCM = 0x0004;
    public static final int CODEC_FLAG2_DROP_FRAME_TIMECODE = 0x00002000;
    public static final int FF_DCT_FASTINT = 1;
    public static final boolean FF_API_VDA_ASYNC = (54 < 55);
    public static final int CODEC_FLAG_AC_PRED = 0x01000000;
    public static final int FF_BUG_UMP4 = 8;
    public static final int FF_CMP_ZERO = 7;
    public static final int FF_PRED_MEDIAN = 2;
    public static final int FF_PROFILE_H264_CONSTRAINED = (1 << 9);
    public static final int CODEC_FLAG_GMC = 0x0020;
    public static final int FF_BUG_DIRECT_BLOCKSIZE = 512;
    public static final int PARSER_FLAG_USE_CODEC_TS = 0x1000;
    public static final int FF_EC_GUESS_MVS = 1;
    public static final int FF_PROFILE_AAC_ELD = 38;
    public static final boolean FF_API_REQUEST_CHANNELS = (54 < 55);
    public static final int LIBAVCODEC_VERSION_MICRO = 100;
    public interface avcodec_default_execute_func_callback extends Callback {
        int apply(AVCodecContext c2, Pointer arg2);
    };
    public interface avcodec_default_execute2_func_callback extends Callback {
        int apply(AVCodecContext c2, Pointer arg2, int int1, int int2);
    };
    public interface av_lockmgr_register_cb_callback extends Callback {
        int apply(PointerByReference mutex, int op);
    };
    /**
     * Accessors for some AVFrame fields.<br>
     * The position of these field in the structure is not part of the ABI,<br>
     * they should not be accessed directly outside libavcodec.<br>
     * Original signature : <code>int64_t av_frame_get_best_effort_timestamp(const AVFrame*)</code>
     */
    long av_frame_get_best_effort_timestamp(AVFrame frame);
    /** Original signature : <code>void av_frame_set_best_effort_timestamp(AVFrame*, int64_t)</code> */
    void av_frame_set_best_effort_timestamp(AVFrame frame, long val);
    /** Original signature : <code>int64_t av_frame_get_pkt_duration(const AVFrame*)</code> */
    long av_frame_get_pkt_duration(AVFrame frame);
    /** Original signature : <code>void av_frame_set_pkt_duration(AVFrame*, int64_t)</code> */
    void av_frame_set_pkt_duration(AVFrame frame, long val);
    /** Original signature : <code>int64_t av_frame_get_pkt_pos(const AVFrame*)</code> */
    long av_frame_get_pkt_pos(AVFrame frame);
    /** Original signature : <code>void av_frame_set_pkt_pos(AVFrame*, int64_t)</code> */
    void av_frame_set_pkt_pos(AVFrame frame, long val);
    /** Original signature : <code>int64_t av_frame_get_channel_layout(const AVFrame*)</code> */
    long av_frame_get_channel_layout(AVFrame frame);
    /** Original signature : <code>void av_frame_set_channel_layout(AVFrame*, int64_t)</code> */
    void av_frame_set_channel_layout(AVFrame frame, long val);
    /** Original signature : <code>int av_frame_get_channels(const AVFrame*)</code> */
    int av_frame_get_channels(AVFrame frame);
    /** Original signature : <code>void av_frame_set_channels(AVFrame*, int)</code> */
    void av_frame_set_channels(AVFrame frame, int val);
    /** Original signature : <code>int av_frame_get_sample_rate(const AVFrame*)</code> */
    int av_frame_get_sample_rate(AVFrame frame);
    /** Original signature : <code>void av_frame_set_sample_rate(AVFrame*, int)</code> */
    void av_frame_set_sample_rate(AVFrame frame, int val);
    /** Original signature : <code>AVDictionary* av_frame_get_metadata(const AVFrame*)</code> */
    PointerByReference av_frame_get_metadata(AVFrame frame);
    /**
     * Original signature : <code>void av_frame_set_metadata(AVFrame*, AVDictionary*)</code><br>
     * @deprecated use the safer method {@link #av_frame_set_metadata(org.javaavc.gen.avcodec.AVFrame, com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    void av_frame_set_metadata(AVFrame frame, Pointer val);
    /** Original signature : <code>void av_frame_set_metadata(AVFrame*, AVDictionary*)</code> */
    void av_frame_set_metadata(AVFrame frame, PointerByReference val);
    /** Original signature : <code>int av_frame_get_decode_error_flags(const AVFrame*)</code> */
    int av_frame_get_decode_error_flags(AVFrame frame);
    /** Original signature : <code>void av_frame_set_decode_error_flags(AVFrame*, int)</code> */
    void av_frame_set_decode_error_flags(AVFrame frame, int val);
    /** Original signature : <code>int av_frame_get_pkt_size(const AVFrame*)</code> */
    int av_frame_get_pkt_size(AVFrame frame);
    /** Original signature : <code>void av_frame_set_pkt_size(AVFrame*, int)</code> */
    void av_frame_set_pkt_size(AVFrame frame, int val);
    /** Original signature : <code>AVCodecDescriptor* av_codec_get_codec_descriptor(const AVCodecContext*)</code> */
    AVCodecDescriptor av_codec_get_codec_descriptor(AVCodecContext avctx);
    /** Original signature : <code>void av_codec_set_codec_descriptor(AVCodecContext*, const AVCodecDescriptor*)</code> */
    void av_codec_set_codec_descriptor(AVCodecContext avctx, AVCodecDescriptor desc);
    /**
     * If c is NULL, returns the first registered codec,<br>
     * if c is non-NULL, returns the next registered codec after c,<br>
     * or NULL if c is the last one.<br>
     * Original signature : <code>AVCodec* av_codec_next(const AVCodec*)</code>
     */
    AVCodec av_codec_next(AVCodec c);
    /**
     * Return the LIBAVCODEC_VERSION_INT constant.<br>
     * Original signature : <code>int avcodec_version()</code>
     */
    int avcodec_version();
    /**
     * Return the libavcodec build-time configuration.<br>
     * Original signature : <code>char* avcodec_configuration()</code>
     */
    String avcodec_configuration();
    /**
     * Return the libavcodec license.<br>
     * Original signature : <code>char* avcodec_license()</code>
     */
    String avcodec_license();
    /**
     * Register the codec codec and initialize libavcodec.<br>
     * * @warning either this function or avcodec_register_all() must be called<br>
     * before any other libavcodec functions.<br>
     * * @see avcodec_register_all()<br>
     * Original signature : <code>void avcodec_register(AVCodec*)</code>
     */
    void avcodec_register(AVCodec codec);
    /**
     * Register all the codecs, parsers and bitstream filters which were enabled at<br>
     * configuration time. If you do not call this function you can select exactly<br>
     * which formats you want to support, by using the individual registration<br>
     * functions.<br>
     * * @see avcodec_register<br>
     * @see av_register_codec_parser<br>
     * @see av_register_bitstream_filter<br>
     * Original signature : <code>void avcodec_register_all()</code>
     */
    void avcodec_register_all();
    /** Original signature : <code>AVCodecContext* avcodec_alloc_context()</code> */
    AVCodecContext avcodec_alloc_context();
    /** Original signature : <code>AVCodecContext* avcodec_alloc_context2(AVMediaType)</code> */
    AVCodecContext avcodec_alloc_context2(LibavcodecLibrary.AVMediaType arg1);
    /** Original signature : <code>void avcodec_get_context_defaults(AVCodecContext*)</code> */
    void avcodec_get_context_defaults(AVCodecContext s);
    /** Original signature : <code>void avcodec_get_context_defaults2(AVCodecContext*, AVMediaType)</code> */
    void avcodec_get_context_defaults2(AVCodecContext s, LibavcodecLibrary.AVMediaType arg1);
    /**
     * Allocate an AVCodecContext and set its fields to default values.  The<br>
     * resulting struct can be deallocated by calling avcodec_close() on it followed<br>
     * by av_free().<br>
     * * @param codec if non-NULL, allocate private data and initialize defaults<br>
     *              for the given codec. It is illegal to then call avcodec_open2()<br>
     *              with a different codec.<br>
     *              If NULL, then the codec-specific defaults won't be initialized,<br>
     *              which may result in suboptimal default settings (this is<br>
     *              important mainly for encoders, e.g. libx264).<br>
     * * @return An AVCodecContext filled with default values or NULL on failure.<br>
     * @see avcodec_get_context_defaults<br>
     * Original signature : <code>AVCodecContext* avcodec_alloc_context3(const AVCodec*)</code>
     */
    AVCodecContext avcodec_alloc_context3(AVCodec codec);
    /**
     * Set the fields of the given AVCodecContext to default values corresponding<br>
     * to the given codec (defaults may be codec-dependent).<br>
     * * Do not call this function if a non-NULL codec has been passed<br>
     * to avcodec_alloc_context3() that allocated this AVCodecContext.<br>
     * If codec is non-NULL, it is illegal to call avcodec_open2() with a<br>
     * different codec on this AVCodecContext.<br>
     * Original signature : <code>int avcodec_get_context_defaults3(AVCodecContext*, const AVCodec*)</code>
     */
    int avcodec_get_context_defaults3(AVCodecContext s, AVCodec codec);
    /**
     * Get the AVClass for AVCodecContext. It can be used in combination with<br>
     * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
     * * @see av_opt_find().<br>
     * Original signature : <code>AVClass* avcodec_get_class()</code>
     */
    Pointer avcodec_get_class();
    /**
     * Get the AVClass for AVFrame. It can be used in combination with<br>
     * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
     * * @see av_opt_find().<br>
     * Original signature : <code>AVClass* avcodec_get_frame_class()</code>
     */
    Pointer avcodec_get_frame_class();
    /**
     * Get the AVClass for AVSubtitleRect. It can be used in combination with<br>
     * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
     * * @see av_opt_find().<br>
     * Original signature : <code>AVClass* avcodec_get_subtitle_rect_class()</code>
     */
    Pointer avcodec_get_subtitle_rect_class();
    /**
     * Copy the settings of the source AVCodecContext into the destination<br>
     * AVCodecContext. The resulting destination codec context will be<br>
     * unopened, i.e. you are required to call avcodec_open2() before you<br>
     * can use this AVCodecContext to decode/encode video/audio data.<br>
     * * @param dest target codec context, should be initialized with<br>
     *             avcodec_alloc_context3(), but otherwise uninitialized<br>
     * @param src source codec context<br>
     * @return AVERROR() on error (e.g. memory allocation error), 0 on success<br>
     * Original signature : <code>int avcodec_copy_context(AVCodecContext*, const AVCodecContext*)</code>
     */
    int avcodec_copy_context(AVCodecContext dest, AVCodecContext src);
    /**
     * Allocate an AVFrame and set its fields to default values.  The resulting<br>
     * struct must be freed using avcodec_free_frame().<br>
     * * @return An AVFrame filled with default values or NULL on failure.<br>
     * @see avcodec_get_frame_defaults<br>
     * Original signature : <code>AVFrame* avcodec_alloc_frame()</code>
     */
    AVFrame avcodec_alloc_frame();
    /**
     * Set the fields of the given AVFrame to default values.<br>
     * * @param frame The AVFrame of which the fields should be set to default values.<br>
     * Original signature : <code>void avcodec_get_frame_defaults(AVFrame*)</code>
     */
    void avcodec_get_frame_defaults(AVFrame frame);
    /**
     * Free the frame and any dynamically allocated objects in it,<br>
     * e.g. extended_data.<br>
     * * @param frame frame to be freed. The pointer will be set to NULL.<br>
     * * @warning this function does NOT free the data buffers themselves<br>
     * (it does not know how, since they might have been allocated with<br>
     *  a custom get_buffer()).<br>
     * Original signature : <code>void avcodec_free_frame(AVFrame**)</code><br>
     * @deprecated use the safer method {@link #avcodec_free_frame(org.javaavc.gen.avcodec.AVFrame.ByReference[])} instead
     */
    @Deprecated
    void avcodec_free_frame(PointerByReference frame);
    /**
     * Free the frame and any dynamically allocated objects in it,<br>
     * e.g. extended_data.<br>
     * * @param frame frame to be freed. The pointer will be set to NULL.<br>
     * * @warning this function does NOT free the data buffers themselves<br>
     * (it does not know how, since they might have been allocated with<br>
     *  a custom get_buffer()).<br>
     * Original signature : <code>void avcodec_free_frame(AVFrame**)</code>
     */
    void avcodec_free_frame(AVFrame.ByReference frame[]);
    /** Original signature : <code>int avcodec_open(AVCodecContext*, AVCodec*)</code> */
    int avcodec_open(AVCodecContext avctx, AVCodec codec);
    /**
     * Initialize the AVCodecContext to use the given AVCodec. Prior to using this<br>
     * function the context has to be allocated with avcodec_alloc_context3().<br>
     * * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),<br>
     * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for<br>
     * retrieving a codec.<br>
     * * @warning This function is not thread safe!<br>
     * * @code<br>
     * avcodec_register_all();<br>
     * av_dict_set(&opts, "b", "2.5M", 0);<br>
     * codec = avcodec_find_decoder(AV_CODEC_ID_H264);<br>
     * if (!codec)<br>
     *     exit(1);<br>
     * * context = avcodec_alloc_context3(codec);<br>
     * * if (avcodec_open2(context, codec, opts) < 0)<br>
     *     exit(1);<br>
     * @endcode<br>
     * * @param avctx The context to initialize.<br>
     * @param codec The codec to open this context for. If a non-NULL codec has been<br>
     *              previously passed to avcodec_alloc_context3() or<br>
     *              avcodec_get_context_defaults3() for this context, then this<br>
     *              parameter MUST be either NULL or equal to the previously passed<br>
     *              codec.<br>
     * @param options A dictionary filled with AVCodecContext and codec-private options.<br>
     *                On return this object will be filled with options that were not found.<br>
     * * @return zero on success, a negative value on error<br>
     * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),<br>
     *      av_dict_set(), av_opt_find().<br>
     * Original signature : <code>int avcodec_open2(AVCodecContext*, const AVCodec*, AVDictionary**)</code>
     */
    int avcodec_open2(AVCodecContext avctx, AVCodec codec, PointerByReference options);
    /**
     * Close a given AVCodecContext and free all the data associated with it<br>
     * (but not the AVCodecContext itself).<br>
     * * Calling this function on an AVCodecContext that hasn't been opened will free<br>
     * the codec-specific data allocated in avcodec_alloc_context3() /<br>
     * avcodec_get_context_defaults3() with a non-NULL codec. Subsequent calls will<br>
     * do nothing.<br>
     * Original signature : <code>int avcodec_close(AVCodecContext*)</code>
     */
    int avcodec_close(AVCodecContext avctx);
    /**
     * Free all allocated data in the given subtitle struct.<br>
     * * @param sub AVSubtitle to free.<br>
     * Original signature : <code>void avsubtitle_free(AVSubtitle*)</code>
     */
    void avsubtitle_free(AVSubtitle sub);
    /**
     * Default packet destructor.<br>
     * Original signature : <code>void av_destruct_packet(AVPacket*)</code>
     */
    void av_destruct_packet(AVPacket pkt);
    /**
     * Initialize optional fields of a packet with default values.<br>
     * * Note, this does not touch the data and size members, which have to be<br>
     * initialized separately.<br>
     * * @param pkt packet<br>
     * Original signature : <code>void av_init_packet(AVPacket*)</code>
     */
    void av_init_packet(AVPacket pkt);
    /**
     * Allocate the payload of a packet and initialize its fields with<br>
     * default values.<br>
     * * @param pkt packet<br>
     * @param size wanted payload size<br>
     * @return 0 if OK, AVERROR_xxx otherwise<br>
     * Original signature : <code>int av_new_packet(AVPacket*, int)</code>
     */
    int av_new_packet(AVPacket pkt, int size);
    /**
     * Reduce packet size, correctly zeroing padding<br>
     * * @param pkt packet<br>
     * @param size new size<br>
     * Original signature : <code>void av_shrink_packet(AVPacket*, int)</code>
     */
    void av_shrink_packet(AVPacket pkt, int size);
    /**
     * Increase packet size, correctly zeroing padding<br>
     * * @param pkt packet<br>
     * @param grow_by number of bytes by which to increase the size of the packet<br>
     * Original signature : <code>int av_grow_packet(AVPacket*, int)</code>
     */
    int av_grow_packet(AVPacket pkt, int grow_by);
    /**
     * @warning This is a hack - the packet memory allocation stuff is broken. The<br>
     * packet is allocated if it was not really allocated.<br>
     * Original signature : <code>int av_dup_packet(AVPacket*)</code>
     */
    int av_dup_packet(AVPacket pkt);
    /**
     * Copy packet, including contents<br>
     * * @return 0 on success, negative AVERROR on fail<br>
     * Original signature : <code>int av_copy_packet(AVPacket*, AVPacket*)</code>
     */
    int av_copy_packet(AVPacket dst, AVPacket src);
    /**
     * Free a packet.<br>
     * * @param pkt packet to free<br>
     * Original signature : <code>void av_free_packet(AVPacket*)</code>
     */
    void av_free_packet(AVPacket pkt);
    /**
     * Allocate new information of a packet.<br>
     * * @param pkt packet<br>
     * @param type side information type<br>
     * @param size side information size<br>
     * @return pointer to fresh allocated data or NULL otherwise<br>
     * Original signature : <code>uint8_t* av_packet_new_side_data(AVPacket*, AVPacketSideDataType, int)</code>
     */
    Pointer av_packet_new_side_data(AVPacket pkt, int type, int size);
    /**
     * Shrink the already allocated side data buffer<br>
     * * @param pkt packet<br>
     * @param type side information type<br>
     * @param size new side information size<br>
     * @return 0 on success, < 0 on failure<br>
     * Original signature : <code>int av_packet_shrink_side_data(AVPacket*, AVPacketSideDataType, int)</code>
     */
    int av_packet_shrink_side_data(AVPacket pkt, int type, int size);
    /**
     * Get side information from packet.<br>
     * * @param pkt packet<br>
     * @param type desired side information type<br>
     * @param size pointer for side information size to store (optional)<br>
     * @return pointer to data if present or NULL otherwise<br>
     * Original signature : <code>uint8_t* av_packet_get_side_data(AVPacket*, AVPacketSideDataType, int*)</code><br>
     * @deprecated use the safer methods {@link #av_packet_get_side_data(org.javaavc.gen.avcodec.AVPacket, int, java.nio.IntBuffer)} and {@link #av_packet_get_side_data(org.javaavc.gen.avcodec.AVPacket, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    Pointer av_packet_get_side_data(AVPacket pkt, int type, IntByReference size);
    /**
     * Get side information from packet.<br>
     * * @param pkt packet<br>
     * @param type desired side information type<br>
     * @param size pointer for side information size to store (optional)<br>
     * @return pointer to data if present or NULL otherwise<br>
     * Original signature : <code>uint8_t* av_packet_get_side_data(AVPacket*, AVPacketSideDataType, int*)</code>
     */
    Pointer av_packet_get_side_data(AVPacket pkt, int type, IntBuffer size);
    /** Original signature : <code>int av_packet_merge_side_data(AVPacket*)</code> */
    int av_packet_merge_side_data(AVPacket pkt);
    /** Original signature : <code>int av_packet_split_side_data(AVPacket*)</code> */
    int av_packet_split_side_data(AVPacket pkt);
    /**
     * Find a registered decoder with a matching codec ID.<br>
     * * @param id AVCodecID of the requested decoder<br>
     * @return A decoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_decoder(AVCodecID)</code>
     */
    AVCodec avcodec_find_decoder(int id);
    /**
     * Find a registered decoder with the specified name.<br>
     * * @param name name of the requested decoder<br>
     * @return A decoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_find_decoder_by_name(java.lang.String)} and {@link #avcodec_find_decoder_by_name(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    AVCodec avcodec_find_decoder_by_name(Pointer name);
    /**
     * Find a registered decoder with the specified name.<br>
     * * @param name name of the requested decoder<br>
     * @return A decoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code>
     */
    AVCodec avcodec_find_decoder_by_name(String name);
    /** Original signature : <code>int avcodec_default_get_buffer(AVCodecContext*, AVFrame*)</code> */
    int avcodec_default_get_buffer(AVCodecContext s, AVFrame pic);
    /** Original signature : <code>void avcodec_default_release_buffer(AVCodecContext*, AVFrame*)</code> */
    void avcodec_default_release_buffer(AVCodecContext s, AVFrame pic);
    /** Original signature : <code>int avcodec_default_reget_buffer(AVCodecContext*, AVFrame*)</code> */
    int avcodec_default_reget_buffer(AVCodecContext s, AVFrame pic);
    /**
     * Return the amount of padding in pixels which the get_buffer callback must<br>
     * provide around the edge of the image for codecs which do not have the<br>
     * CODEC_FLAG_EMU_EDGE flag.<br>
     * * @return Required padding in pixels.<br>
     * Original signature : <code>int avcodec_get_edge_width()</code>
     */
    int avcodec_get_edge_width();
    /**
     * Modify width and height values so that they will result in a memory<br>
     * buffer that is acceptable for the codec if you do not use any horizontal<br>
     * padding.<br>
     * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
     * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
     * according to avcodec_get_edge_width() before.<br>
     * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_align_dimensions(org.javaavc.gen.avcodec.AVCodecContext, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_align_dimensions(org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void avcodec_align_dimensions(AVCodecContext s, IntByReference width, IntByReference height);
    /**
     * Modify width and height values so that they will result in a memory<br>
     * buffer that is acceptable for the codec if you do not use any horizontal<br>
     * padding.<br>
     * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
     * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
     * according to avcodec_get_edge_width() before.<br>
     * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code>
     */
    void avcodec_align_dimensions(AVCodecContext s, IntBuffer width, IntBuffer height);
    /**
     * Modify width and height values so that they will result in a memory<br>
     * buffer that is acceptable for the codec if you also ensure that all<br>
     * line sizes are a multiple of the respective linesize_align[i].<br>
     * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
     * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
     * according to avcodec_get_edge_width() before.<br>
     * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[8])</code><br>
     * @deprecated use the safer methods {@link #avcodec_align_dimensions2(org.javaavc.gen.avcodec.AVCodecContext, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_align_dimensions2(org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void avcodec_align_dimensions2(AVCodecContext s, IntByReference width, IntByReference height, IntByReference linesize_align);
    /**
     * Modify width and height values so that they will result in a memory<br>
     * buffer that is acceptable for the codec if you also ensure that all<br>
     * line sizes are a multiple of the respective linesize_align[i].<br>
     * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
     * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
     * according to avcodec_get_edge_width() before.<br>
     * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[8])</code>
     */
    void avcodec_align_dimensions2(AVCodecContext s, IntBuffer width, IntBuffer height, IntBuffer linesize_align);
    /**
     * Wrapper function which calls avcodec_decode_audio4.<br>
     * * @deprecated Use avcodec_decode_audio4 instead.<br>
     * * Decode the audio frame of size avpkt->size from avpkt->data into samples.<br>
     * Some decoders may support multiple frames in a single AVPacket, such<br>
     * decoders would then just decode the first frame. In this case,<br>
     * avcodec_decode_audio3 has to be called again with an AVPacket that contains<br>
     * the remaining data in order to decode the second frame etc.<br>
     * If no frame<br>
     * could be outputted, frame_size_ptr is zero. Otherwise, it is the<br>
     * decompressed frame size in bytes.<br>
     * * @warning You must set frame_size_ptr to the allocated size of the<br>
     * output buffer before calling avcodec_decode_audio3().<br>
     * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
     * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
     * bits at once and could read over the end.<br>
     * * @warning The end of the input buffer avpkt->data should be set to 0 to ensure that<br>
     * no overreading happens for damaged MPEG streams.<br>
     * * @warning You must not provide a custom get_buffer() when using<br>
     * avcodec_decode_audio3().  Doing so will override it with<br>
     * avcodec_default_get_buffer.  Use avcodec_decode_audio4() instead,<br>
     * which does allow the application to provide a custom get_buffer().<br>
     * * @note You might have to align the input buffer avpkt->data and output buffer<br>
     * samples. The alignment requirements depend on the CPU: On some CPUs it isn't<br>
     * necessary at all, on others it won't work at all if not aligned and on others<br>
     * it will work but it will have an impact on performance.<br>
     * * In practice, avpkt->data should have 4 byte alignment at minimum and<br>
     * samples should be 16 byte aligned unless the CPU doesn't need it<br>
     * (AltiVec and SSE do).<br>
     * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
     * between input and output, these need to be fed with avpkt->data=NULL,<br>
     * avpkt->size=0 at the end to return the remaining frames.<br>
     * * @param avctx the codec context<br>
     * @param[out] samples the output buffer, sample type in avctx->sample_fmt<br>
     *                     If the sample format is planar, each channel plane will<br>
     *                     be the same size, with no padding between channels.<br>
     * @param[in,out] frame_size_ptr the output buffer size in bytes<br>
     * @param[in] avpkt The input AVPacket containing the input buffer.<br>
     *            You can create such packet with av_init_packet() and by then setting<br>
     *            data and size, some decoders might in addition need other fields.<br>
     *            All decoders are designed to use the least fields possible though.<br>
     * @return On error a negative value is returned, otherwise the number of bytes<br>
     * used or zero if no frame data was decompressed (used) from the input AVPacket.<br>
     * Original signature : <code>int avcodec_decode_audio3(AVCodecContext*, int16_t*, int*, AVPacket*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_decode_audio3(org.javaavc.gen.avcodec.AVCodecContext, java.nio.ShortBuffer, java.nio.IntBuffer, org.javaavc.gen.avcodec.AVPacket)} and {@link #avcodec_decode_audio3(org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.IntByReference, org.javaavc.gen.avcodec.AVPacket)} instead
     */
    @Deprecated
    int avcodec_decode_audio3(AVCodecContext avctx, ShortByReference samples, IntByReference frame_size_ptr, AVPacket avpkt);
    /**
     * Wrapper function which calls avcodec_decode_audio4.<br>
     * * @deprecated Use avcodec_decode_audio4 instead.<br>
     * * Decode the audio frame of size avpkt->size from avpkt->data into samples.<br>
     * Some decoders may support multiple frames in a single AVPacket, such<br>
     * decoders would then just decode the first frame. In this case,<br>
     * avcodec_decode_audio3 has to be called again with an AVPacket that contains<br>
     * the remaining data in order to decode the second frame etc.<br>
     * If no frame<br>
     * could be outputted, frame_size_ptr is zero. Otherwise, it is the<br>
     * decompressed frame size in bytes.<br>
     * * @warning You must set frame_size_ptr to the allocated size of the<br>
     * output buffer before calling avcodec_decode_audio3().<br>
     * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
     * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
     * bits at once and could read over the end.<br>
     * * @warning The end of the input buffer avpkt->data should be set to 0 to ensure that<br>
     * no overreading happens for damaged MPEG streams.<br>
     * * @warning You must not provide a custom get_buffer() when using<br>
     * avcodec_decode_audio3().  Doing so will override it with<br>
     * avcodec_default_get_buffer.  Use avcodec_decode_audio4() instead,<br>
     * which does allow the application to provide a custom get_buffer().<br>
     * * @note You might have to align the input buffer avpkt->data and output buffer<br>
     * samples. The alignment requirements depend on the CPU: On some CPUs it isn't<br>
     * necessary at all, on others it won't work at all if not aligned and on others<br>
     * it will work but it will have an impact on performance.<br>
     * * In practice, avpkt->data should have 4 byte alignment at minimum and<br>
     * samples should be 16 byte aligned unless the CPU doesn't need it<br>
     * (AltiVec and SSE do).<br>
     * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
     * between input and output, these need to be fed with avpkt->data=NULL,<br>
     * avpkt->size=0 at the end to return the remaining frames.<br>
     * * @param avctx the codec context<br>
     * @param[out] samples the output buffer, sample type in avctx->sample_fmt<br>
     *                     If the sample format is planar, each channel plane will<br>
     *                     be the same size, with no padding between channels.<br>
     * @param[in,out] frame_size_ptr the output buffer size in bytes<br>
     * @param[in] avpkt The input AVPacket containing the input buffer.<br>
     *            You can create such packet with av_init_packet() and by then setting<br>
     *            data and size, some decoders might in addition need other fields.<br>
     *            All decoders are designed to use the least fields possible though.<br>
     * @return On error a negative value is returned, otherwise the number of bytes<br>
     * used or zero if no frame data was decompressed (used) from the input AVPacket.<br>
     * Original signature : <code>int avcodec_decode_audio3(AVCodecContext*, int16_t*, int*, AVPacket*)</code>
     */
    int avcodec_decode_audio3(AVCodecContext avctx, ShortBuffer samples, IntBuffer frame_size_ptr, AVPacket avpkt);
    /**
     * Decode the audio frame of size avpkt->size from avpkt->data into frame.<br>
     * * Some decoders may support multiple frames in a single AVPacket. Such<br>
     * decoders would then just decode the first frame. In this case,<br>
     * avcodec_decode_audio4 has to be called again with an AVPacket containing<br>
     * the remaining data in order to decode the second frame, etc...<br>
     * Even if no frames are returned, the packet needs to be fed to the decoder<br>
     * with remaining data until it is completely consumed or an error occurs.<br>
     * * @warning The input buffer, avpkt->data must be FF_INPUT_BUFFER_PADDING_SIZE<br>
     *          larger than the actual read bytes because some optimized bitstream<br>
     *          readers read 32 or 64 bits at once and could read over the end.<br>
     * * @note You might have to align the input buffer. The alignment requirements<br>
     *       depend on the CPU and the decoder.<br>
     * * @param      avctx the codec context<br>
     * @param[out] frame The AVFrame in which to store decoded audio samples.<br>
     *                   Decoders request a buffer of a particular size by setting<br>
     *                   AVFrame.nb_samples prior to calling get_buffer(). The<br>
     *                   decoder may, however, only utilize part of the buffer by<br>
     *                   setting AVFrame.nb_samples to a smaller value in the<br>
     *                   output frame.<br>
     * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is<br>
     *                           non-zero.<br>
     * @param[in]  avpkt The input AVPacket containing the input buffer.<br>
     *                   At least avpkt->data and avpkt->size should be set. Some<br>
     *                   decoders might also require additional fields to be set.<br>
     * @return A negative error code is returned if an error occurred during<br>
     *         decoding, otherwise the number of bytes consumed from the input<br>
     *         AVPacket is returned.<br>
     * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_decode_audio4(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVFrame, java.nio.IntBuffer, org.javaavc.gen.avcodec.AVPacket)} and {@link #avcodec_decode_audio4(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVFrame, com.sun.jna.ptr.IntByReference, org.javaavc.gen.avcodec.AVPacket)} instead
     */
    @Deprecated
    int avcodec_decode_audio4(AVCodecContext avctx, AVFrame frame, IntByReference got_frame_ptr, AVPacket avpkt);
    /**
     * Decode the audio frame of size avpkt->size from avpkt->data into frame.<br>
     * * Some decoders may support multiple frames in a single AVPacket. Such<br>
     * decoders would then just decode the first frame. In this case,<br>
     * avcodec_decode_audio4 has to be called again with an AVPacket containing<br>
     * the remaining data in order to decode the second frame, etc...<br>
     * Even if no frames are returned, the packet needs to be fed to the decoder<br>
     * with remaining data until it is completely consumed or an error occurs.<br>
     * * @warning The input buffer, avpkt->data must be FF_INPUT_BUFFER_PADDING_SIZE<br>
     *          larger than the actual read bytes because some optimized bitstream<br>
     *          readers read 32 or 64 bits at once and could read over the end.<br>
     * * @note You might have to align the input buffer. The alignment requirements<br>
     *       depend on the CPU and the decoder.<br>
     * * @param      avctx the codec context<br>
     * @param[out] frame The AVFrame in which to store decoded audio samples.<br>
     *                   Decoders request a buffer of a particular size by setting<br>
     *                   AVFrame.nb_samples prior to calling get_buffer(). The<br>
     *                   decoder may, however, only utilize part of the buffer by<br>
     *                   setting AVFrame.nb_samples to a smaller value in the<br>
     *                   output frame.<br>
     * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is<br>
     *                           non-zero.<br>
     * @param[in]  avpkt The input AVPacket containing the input buffer.<br>
     *                   At least avpkt->data and avpkt->size should be set. Some<br>
     *                   decoders might also require additional fields to be set.<br>
     * @return A negative error code is returned if an error occurred during<br>
     *         decoding, otherwise the number of bytes consumed from the input<br>
     *         AVPacket is returned.<br>
     * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code>
     */
    int avcodec_decode_audio4(AVCodecContext avctx, AVFrame frame, IntBuffer got_frame_ptr, AVPacket avpkt);
    /**
     * Decode the video frame of size avpkt->size from avpkt->data into picture.<br>
     * Some decoders may support multiple frames in a single AVPacket, such<br>
     * decoders would then just decode the first frame.<br>
     * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
     * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
     * bits at once and could read over the end.<br>
     * * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
     * no overreading happens for damaged MPEG streams.<br>
     * * @note You might have to align the input buffer avpkt->data.<br>
     * The alignment requirements depend on the CPU: on some CPUs it isn't<br>
     * necessary at all, on others it won't work at all if not aligned and on others<br>
     * it will work but it will have an impact on performance.<br>
     * * In practice, avpkt->data should have 4 byte alignment at minimum.<br>
     * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
     * between input and output, these need to be fed with avpkt->data=NULL,<br>
     * avpkt->size=0 at the end to return the remaining frames.<br>
     * * @param avctx the codec context<br>
     * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
     *             Use avcodec_alloc_frame to get an AVFrame, the codec will<br>
     *             allocate memory for the actual bitmap.<br>
     *             with default get/release_buffer(), the decoder frees/reuses the bitmap as it sees fit.<br>
     *             with overridden get/release_buffer() (needs CODEC_CAP_DR1) the user decides into what buffer the decoder<br>
     *                   decodes and the decoder tells the user once it does not need the data anymore,<br>
     *                   the user app can at this point free/reuse/keep the memory as it sees fit.<br>
     * * @param[in] avpkt The input AVpacket containing the input buffer.<br>
     *            You can create such packet with av_init_packet() and by then setting<br>
     *            data and size, some decoders might in addition need other fields like<br>
     *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
     *            fields possible.<br>
     * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
     * @return On error a negative value is returned, otherwise the number of bytes<br>
     * used or zero if no frame could be decompressed.<br>
     * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_decode_video2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVFrame, java.nio.IntBuffer, org.javaavc.gen.avcodec.AVPacket)} and {@link #avcodec_decode_video2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVFrame, com.sun.jna.ptr.IntByReference, org.javaavc.gen.avcodec.AVPacket)} instead
     */
    @Deprecated
    int avcodec_decode_video2(AVCodecContext avctx, AVFrame picture, IntByReference got_picture_ptr, AVPacket avpkt);
    /**
     * Decode the video frame of size avpkt->size from avpkt->data into picture.<br>
     * Some decoders may support multiple frames in a single AVPacket, such<br>
     * decoders would then just decode the first frame.<br>
     * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
     * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
     * bits at once and could read over the end.<br>
     * * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
     * no overreading happens for damaged MPEG streams.<br>
     * * @note You might have to align the input buffer avpkt->data.<br>
     * The alignment requirements depend on the CPU: on some CPUs it isn't<br>
     * necessary at all, on others it won't work at all if not aligned and on others<br>
     * it will work but it will have an impact on performance.<br>
     * * In practice, avpkt->data should have 4 byte alignment at minimum.<br>
     * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
     * between input and output, these need to be fed with avpkt->data=NULL,<br>
     * avpkt->size=0 at the end to return the remaining frames.<br>
     * * @param avctx the codec context<br>
     * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
     *             Use avcodec_alloc_frame to get an AVFrame, the codec will<br>
     *             allocate memory for the actual bitmap.<br>
     *             with default get/release_buffer(), the decoder frees/reuses the bitmap as it sees fit.<br>
     *             with overridden get/release_buffer() (needs CODEC_CAP_DR1) the user decides into what buffer the decoder<br>
     *                   decodes and the decoder tells the user once it does not need the data anymore,<br>
     *                   the user app can at this point free/reuse/keep the memory as it sees fit.<br>
     * * @param[in] avpkt The input AVpacket containing the input buffer.<br>
     *            You can create such packet with av_init_packet() and by then setting<br>
     *            data and size, some decoders might in addition need other fields like<br>
     *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
     *            fields possible.<br>
     * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
     * @return On error a negative value is returned, otherwise the number of bytes<br>
     * used or zero if no frame could be decompressed.<br>
     * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code>
     */
    int avcodec_decode_video2(AVCodecContext avctx, AVFrame picture, IntBuffer got_picture_ptr, AVPacket avpkt);
    /**
     * Decode a subtitle message.<br>
     * Return a negative value on error, otherwise return the number of bytes used.<br>
     * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
     * Otherwise, the subtitle is stored in *sub.<br>
     * Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is for<br>
     * simplicity, because the performance difference is expect to be negligible<br>
     * and reusing a get_buffer written for video codecs would probably perform badly<br>
     * due to a potentially very different allocation pattern.<br>
     * * @param avctx the codec context<br>
     * @param[out] sub The AVSubtitle in which the decoded subtitle will be stored, must be<br>
     * freed with avsubtitle_free if *got_sub_ptr is set.<br>
     * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
     * @param[in] avpkt The input AVPacket containing the input buffer.<br>
     * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_decode_subtitle2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVSubtitle, java.nio.IntBuffer, org.javaavc.gen.avcodec.AVPacket)} and {@link #avcodec_decode_subtitle2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVSubtitle, com.sun.jna.ptr.IntByReference, org.javaavc.gen.avcodec.AVPacket)} instead
     */
    @Deprecated
    int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub, IntByReference got_sub_ptr, AVPacket avpkt);
    /**
     * Decode a subtitle message.<br>
     * Return a negative value on error, otherwise return the number of bytes used.<br>
     * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
     * Otherwise, the subtitle is stored in *sub.<br>
     * Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is for<br>
     * simplicity, because the performance difference is expect to be negligible<br>
     * and reusing a get_buffer written for video codecs would probably perform badly<br>
     * due to a potentially very different allocation pattern.<br>
     * * @param avctx the codec context<br>
     * @param[out] sub The AVSubtitle in which the decoded subtitle will be stored, must be<br>
     * freed with avsubtitle_free if *got_sub_ptr is set.<br>
     * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
     * @param[in] avpkt The input AVPacket containing the input buffer.<br>
     * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code>
     */
    int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub, IntBuffer got_sub_ptr, AVPacket avpkt);
    /** Original signature : <code>AVCodecParser* av_parser_next(AVCodecParser*)</code> */
    AVCodecParser av_parser_next(AVCodecParser c);
    /** Original signature : <code>void av_register_codec_parser(AVCodecParser*)</code> */
    void av_register_codec_parser(AVCodecParser parser);
    /** Original signature : <code>AVCodecParserContext* av_parser_init(int)</code> */
    AVCodecParserContext av_parser_init(int codec_id);
    /**
     * Parse a packet.<br>
     * * @param s             parser context.<br>
     * @param avctx         codec context.<br>
     * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
     * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
     * @param buf           input buffer.<br>
     * @param buf_size      input length, to signal EOF, this should be 0 (so that the last frame can be output).<br>
     * @param pts           input presentation timestamp.<br>
     * @param dts           input decoding timestamp.<br>
     * @param pos           input byte position in stream.<br>
     * @return the number of bytes of the input bitstream used.<br>
     * * Example:<br>
     * @code<br>
     *   while(in_len){<br>
     *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
     *                                        in_data, in_len,<br>
     *                                        pts, dts, pos);<br>
     *       in_data += len;<br>
     *       in_len  -= len;<br>
     * *       if(size)<br>
     *          decode_frame(data, size);<br>
     *   }<br>
     * @endcode<br>
     * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
     * @deprecated use the safer methods {@link #av_parser_parse2(org.javaavc.gen.avcodec.AVCodecParserContext, org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.ByteBuffer, int, long, long, long)} and {@link #av_parser_parse2(org.javaavc.gen.avcodec.AVCodecParserContext, org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, long, long, long)} instead
     */
    @Deprecated
    int av_parser_parse2(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, long pts, long dts, long pos);
    /**
     * Parse a packet.<br>
     * * @param s             parser context.<br>
     * @param avctx         codec context.<br>
     * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
     * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
     * @param buf           input buffer.<br>
     * @param buf_size      input length, to signal EOF, this should be 0 (so that the last frame can be output).<br>
     * @param pts           input presentation timestamp.<br>
     * @param dts           input decoding timestamp.<br>
     * @param pos           input byte position in stream.<br>
     * @return the number of bytes of the input bitstream used.<br>
     * * Example:<br>
     * @code<br>
     *   while(in_len){<br>
     *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
     *                                        in_data, in_len,<br>
     *                                        pts, dts, pos);<br>
     *       in_data += len;<br>
     *       in_len  -= len;<br>
     * *       if(size)<br>
     *          decode_frame(data, size);<br>
     *   }<br>
     * @endcode<br>
     * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code>
     */
    int av_parser_parse2(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, ByteBuffer buf, int buf_size, long pts, long dts, long pos);
    /**
     * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed<br>
     * @deprecated use AVBitstreamFilter<br>
     * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
     * @deprecated use the safer methods {@link #av_parser_change(org.javaavc.gen.avcodec.AVCodecParserContext, org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.ByteBuffer, int, int)} and {@link #av_parser_change(org.javaavc.gen.avcodec.AVCodecParserContext, org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, int)} instead
     */
    @Deprecated
    int av_parser_change(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, int keyframe);
    /**
     * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed<br>
     * @deprecated use AVBitstreamFilter<br>
     * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code>
     */
    int av_parser_change(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, ByteBuffer buf, int buf_size, int keyframe);
    /** Original signature : <code>void av_parser_close(AVCodecParserContext*)</code> */
    void av_parser_close(AVCodecParserContext s);
    /**
     * Find a registered encoder with a matching codec ID.<br>
     * * @param id AVCodecID of the requested encoder<br>
     * @return An encoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_encoder(AVCodecID)</code>
     */
    AVCodec avcodec_find_encoder(int id);
    /**
     * Find a registered encoder with the specified name.<br>
     * * @param name name of the requested encoder<br>
     * @return An encoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_find_encoder_by_name(java.lang.String)} and {@link #avcodec_find_encoder_by_name(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    AVCodec avcodec_find_encoder_by_name(Pointer name);
    /**
     * Find a registered encoder with the specified name.<br>
     * * @param name name of the requested encoder<br>
     * @return An encoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code>
     */
    AVCodec avcodec_find_encoder_by_name(String name);
    /**
     * Encode an audio frame from samples into buf.<br>
     * * @deprecated Use avcodec_encode_audio2 instead.<br>
     * * @note The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large.<br>
     * However, for codecs with avctx->frame_size equal to 0 (e.g. PCM) the user<br>
     * will know how much space is needed because it depends on the value passed<br>
     * in buf_size as described below. In that case a lower value can be used.<br>
     * * @param avctx the codec context<br>
     * @param[out] buf the output buffer<br>
     * @param[in] buf_size the output buffer size<br>
     * @param[in] samples the input buffer containing the samples<br>
     * The number of samples read from this buffer is frame_size*channels,<br>
     * both of which are defined in avctx.<br>
     * For codecs which have avctx->frame_size equal to 0 (e.g. PCM) the number of<br>
     * samples read from samples is equal to:<br>
     * buf_size * 8 / (avctx->channels * av_get_bits_per_sample(avctx->codec_id))<br>
     * This also implies that av_get_bits_per_sample() must not return 0 for these<br>
     * codecs.<br>
     * @return On error a negative value is returned, on success zero or the number<br>
     * of bytes used to encode the data read from the input buffer.<br>
     * Original signature : <code>int avcodec_encode_audio(AVCodecContext*, uint8_t*, int, const short*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_encode_audio(org.javaavc.gen.avcodec.AVCodecContext, java.nio.ByteBuffer, int, java.nio.ShortBuffer)} and {@link #avcodec_encode_audio(org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.Pointer, int, com.sun.jna.ptr.ShortByReference)} instead
     */
    @Deprecated
    int avcodec_encode_audio(AVCodecContext avctx, Pointer buf, int buf_size, ShortByReference samples);
    /**
     * Encode an audio frame from samples into buf.<br>
     * * @deprecated Use avcodec_encode_audio2 instead.<br>
     * * @note The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large.<br>
     * However, for codecs with avctx->frame_size equal to 0 (e.g. PCM) the user<br>
     * will know how much space is needed because it depends on the value passed<br>
     * in buf_size as described below. In that case a lower value can be used.<br>
     * * @param avctx the codec context<br>
     * @param[out] buf the output buffer<br>
     * @param[in] buf_size the output buffer size<br>
     * @param[in] samples the input buffer containing the samples<br>
     * The number of samples read from this buffer is frame_size*channels,<br>
     * both of which are defined in avctx.<br>
     * For codecs which have avctx->frame_size equal to 0 (e.g. PCM) the number of<br>
     * samples read from samples is equal to:<br>
     * buf_size * 8 / (avctx->channels * av_get_bits_per_sample(avctx->codec_id))<br>
     * This also implies that av_get_bits_per_sample() must not return 0 for these<br>
     * codecs.<br>
     * @return On error a negative value is returned, on success zero or the number<br>
     * of bytes used to encode the data read from the input buffer.<br>
     * Original signature : <code>int avcodec_encode_audio(AVCodecContext*, uint8_t*, int, const short*)</code>
     */
    int avcodec_encode_audio(AVCodecContext avctx, ByteBuffer buf, int buf_size, ShortBuffer samples);
    /**
     * Encode a frame of audio.<br>
     * * Takes input samples from frame and writes the next output packet, if<br>
     * available, to avpkt. The output packet does not necessarily contain data for<br>
     * the most recent frame, as encoders can delay, split, and combine input frames<br>
     * internally as needed.<br>
     * * @param avctx     codec context<br>
     * @param avpkt     output AVPacket.<br>
     *                  The user can supply an output buffer by setting<br>
     *                  avpkt->data and avpkt->size prior to calling the<br>
     *                  function, but if the size of the user-provided data is not<br>
     *                  large enough, encoding will fail. If avpkt->data and<br>
     *                  avpkt->size are set, avpkt->destruct must also be set. All<br>
     *                  other AVPacket fields will be reset by the encoder using<br>
     *                  av_init_packet(). If avpkt->data is NULL, the encoder will<br>
     *                  allocate it. The encoder will set avpkt->size to the size<br>
     *                  of the output packet.<br>
     * *                  If this function fails or produces no output, avpkt will be<br>
     *                  freed using av_free_packet() (i.e. avpkt->destruct will be<br>
     *                  called to free the user supplied buffer).<br>
     * @param[in] frame AVFrame containing the raw audio data to be encoded.<br>
     *                  May be NULL when flushing an encoder that has the<br>
     *                  CODEC_CAP_DELAY capability set.<br>
     *                  If CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
     *                  can have any number of samples.<br>
     *                  If it is not set, frame->nb_samples must be equal to<br>
     *                  avctx->frame_size for all frames except the last.<br>
     *                  The final frame may be smaller than avctx->frame_size.<br>
     * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
     *                            output packet is non-empty, and to 0 if it is<br>
     *                            empty. If the function returns an error, the<br>
     *                            packet can be assumed to be invalid, and the<br>
     *                            value of got_packet_ptr is undefined and should<br>
     *                            not be used.<br>
     * @return          0 on success, negative error code on failure<br>
     * Original signature : <code>int avcodec_encode_audio2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_encode_audio2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVPacket, org.javaavc.gen.avcodec.AVFrame, java.nio.IntBuffer)} and {@link #avcodec_encode_audio2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVPacket, org.javaavc.gen.avcodec.AVFrame, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int avcodec_encode_audio2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntByReference got_packet_ptr);
    /**
     * Encode a frame of audio.<br>
     * * Takes input samples from frame and writes the next output packet, if<br>
     * available, to avpkt. The output packet does not necessarily contain data for<br>
     * the most recent frame, as encoders can delay, split, and combine input frames<br>
     * internally as needed.<br>
     * * @param avctx     codec context<br>
     * @param avpkt     output AVPacket.<br>
     *                  The user can supply an output buffer by setting<br>
     *                  avpkt->data and avpkt->size prior to calling the<br>
     *                  function, but if the size of the user-provided data is not<br>
     *                  large enough, encoding will fail. If avpkt->data and<br>
     *                  avpkt->size are set, avpkt->destruct must also be set. All<br>
     *                  other AVPacket fields will be reset by the encoder using<br>
     *                  av_init_packet(). If avpkt->data is NULL, the encoder will<br>
     *                  allocate it. The encoder will set avpkt->size to the size<br>
     *                  of the output packet.<br>
     * *                  If this function fails or produces no output, avpkt will be<br>
     *                  freed using av_free_packet() (i.e. avpkt->destruct will be<br>
     *                  called to free the user supplied buffer).<br>
     * @param[in] frame AVFrame containing the raw audio data to be encoded.<br>
     *                  May be NULL when flushing an encoder that has the<br>
     *                  CODEC_CAP_DELAY capability set.<br>
     *                  If CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
     *                  can have any number of samples.<br>
     *                  If it is not set, frame->nb_samples must be equal to<br>
     *                  avctx->frame_size for all frames except the last.<br>
     *                  The final frame may be smaller than avctx->frame_size.<br>
     * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
     *                            output packet is non-empty, and to 0 if it is<br>
     *                            empty. If the function returns an error, the<br>
     *                            packet can be assumed to be invalid, and the<br>
     *                            value of got_packet_ptr is undefined and should<br>
     *                            not be used.<br>
     * @return          0 on success, negative error code on failure<br>
     * Original signature : <code>int avcodec_encode_audio2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code>
     */
    int avcodec_encode_audio2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntBuffer got_packet_ptr);
    /**
     * Original signature : <code>int avcodec_encode_video(AVCodecContext*, uint8_t*, int, const AVFrame*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_encode_video(org.javaavc.gen.avcodec.AVCodecContext, java.nio.ByteBuffer, int, org.javaavc.gen.avcodec.AVFrame)} and {@link #avcodec_encode_video(org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.Pointer, int, org.javaavc.gen.avcodec.AVFrame)} instead
     */
    @Deprecated
    int avcodec_encode_video(AVCodecContext avctx, Pointer buf, int buf_size, AVFrame pict);
    /** Original signature : <code>int avcodec_encode_video(AVCodecContext*, uint8_t*, int, const AVFrame*)</code> */
    int avcodec_encode_video(AVCodecContext avctx, ByteBuffer buf, int buf_size, AVFrame pict);
    /**
     * Encode a frame of video.<br>
     * * Takes input raw video data from frame and writes the next output packet, if<br>
     * available, to avpkt. The output packet does not necessarily contain data for<br>
     * the most recent frame, as encoders can delay and reorder input frames<br>
     * internally as needed.<br>
     * * @param avctx     codec context<br>
     * @param avpkt     output AVPacket.<br>
     *                  The user can supply an output buffer by setting<br>
     *                  avpkt->data and avpkt->size prior to calling the<br>
     *                  function, but if the size of the user-provided data is not<br>
     *                  large enough, encoding will fail. All other AVPacket fields<br>
     *                  will be reset by the encoder using av_init_packet(). If<br>
     *                  avpkt->data is NULL, the encoder will allocate it.<br>
     *                  The encoder will set avpkt->size to the size of the<br>
     *                  output packet. The returned data (if any) belongs to the<br>
     *                  caller, he is responsible for freeing it.<br>
     * *                  If this function fails or produces no output, avpkt will be<br>
     *                  freed using av_free_packet() (i.e. avpkt->destruct will be<br>
     *                  called to free the user supplied buffer).<br>
     * @param[in] frame AVFrame containing the raw video data to be encoded.<br>
     *                  May be NULL when flushing an encoder that has the<br>
     *                  CODEC_CAP_DELAY capability set.<br>
     * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
     *                            output packet is non-empty, and to 0 if it is<br>
     *                            empty. If the function returns an error, the<br>
     *                            packet can be assumed to be invalid, and the<br>
     *                            value of got_packet_ptr is undefined and should<br>
     *                            not be used.<br>
     * @return          0 on success, negative error code on failure<br>
     * Original signature : <code>int avcodec_encode_video2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_encode_video2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVPacket, org.javaavc.gen.avcodec.AVFrame, java.nio.IntBuffer)} and {@link #avcodec_encode_video2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.AVPacket, org.javaavc.gen.avcodec.AVFrame, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int avcodec_encode_video2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntByReference got_packet_ptr);
    /**
     * Encode a frame of video.<br>
     * * Takes input raw video data from frame and writes the next output packet, if<br>
     * available, to avpkt. The output packet does not necessarily contain data for<br>
     * the most recent frame, as encoders can delay and reorder input frames<br>
     * internally as needed.<br>
     * * @param avctx     codec context<br>
     * @param avpkt     output AVPacket.<br>
     *                  The user can supply an output buffer by setting<br>
     *                  avpkt->data and avpkt->size prior to calling the<br>
     *                  function, but if the size of the user-provided data is not<br>
     *                  large enough, encoding will fail. All other AVPacket fields<br>
     *                  will be reset by the encoder using av_init_packet(). If<br>
     *                  avpkt->data is NULL, the encoder will allocate it.<br>
     *                  The encoder will set avpkt->size to the size of the<br>
     *                  output packet. The returned data (if any) belongs to the<br>
     *                  caller, he is responsible for freeing it.<br>
     * *                  If this function fails or produces no output, avpkt will be<br>
     *                  freed using av_free_packet() (i.e. avpkt->destruct will be<br>
     *                  called to free the user supplied buffer).<br>
     * @param[in] frame AVFrame containing the raw video data to be encoded.<br>
     *                  May be NULL when flushing an encoder that has the<br>
     *                  CODEC_CAP_DELAY capability set.<br>
     * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
     *                            output packet is non-empty, and to 0 if it is<br>
     *                            empty. If the function returns an error, the<br>
     *                            packet can be assumed to be invalid, and the<br>
     *                            value of got_packet_ptr is undefined and should<br>
     *                            not be used.<br>
     * @return          0 on success, negative error code on failure<br>
     * Original signature : <code>int avcodec_encode_video2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code>
     */
    int avcodec_encode_video2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntBuffer got_packet_ptr);
    /**
     * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_encode_subtitle(org.javaavc.gen.avcodec.AVCodecContext, java.nio.ByteBuffer, int, org.javaavc.gen.avcodec.AVSubtitle)} and {@link #avcodec_encode_subtitle(org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.Pointer, int, org.javaavc.gen.avcodec.AVSubtitle)} instead
     */
    @Deprecated
    int avcodec_encode_subtitle(AVCodecContext avctx, Pointer buf, int buf_size, AVSubtitle sub);
    /** Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code> */
    int avcodec_encode_subtitle(AVCodecContext avctx, ByteBuffer buf, int buf_size, AVSubtitle sub);
    /** Original signature : <code>ReSampleContext* av_audio_resample_init(int, int, int, int, AVSampleFormat, AVSampleFormat, int, int, int, double)</code> */
    PointerByReference av_audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate, LibavcodecLibrary.AVSampleFormat sample_fmt_out, LibavcodecLibrary.AVSampleFormat sample_fmt_in, int filter_length, int log2_phase_count, int linear, double cutoff);
    /**
     * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
     * @deprecated use the safer methods {@link #audio_resample(com.sun.jna.ptr.PointerByReference, java.nio.ShortBuffer, java.nio.ShortBuffer, int)} and {@link #audio_resample(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.ShortByReference, int)} instead
     */
    @Deprecated
    int audio_resample(Pointer s, ShortByReference output, ShortByReference input, int nb_samples);
    /** Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code> */
    int audio_resample(PointerByReference s, ShortBuffer output, ShortBuffer input, int nb_samples);
    /** Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code> */
    int audio_resample(PointerByReference s, ShortByReference output, ShortByReference input, int nb_samples);
    /**
     * Original signature : <code>void audio_resample_close(ReSampleContext*)</code><br>
     * @deprecated use the safer method {@link #audio_resample_close(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    void audio_resample_close(Pointer s);
    /** Original signature : <code>void audio_resample_close(ReSampleContext*)</code> */
    void audio_resample_close(PointerByReference s);
    /** Original signature : <code>AVResampleContext* av_resample_init(int, int, int, int, int, double)</code> */
    LibavcodecLibrary.AVResampleContext av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);
    /**
     * Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code><br>
     * @deprecated use the safer methods {@link #av_resample(org.javaavc.gen.avcodec.LibavcodecLibrary.AVResampleContext, java.nio.ShortBuffer, java.nio.ShortBuffer, java.nio.IntBuffer, int, int, int)} and {@link #av_resample(org.javaavc.gen.avcodec.LibavcodecLibrary.AVResampleContext, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.IntByReference, int, int, int)} instead
     */
    @Deprecated
    int av_resample(LibavcodecLibrary.AVResampleContext c, ShortByReference dst, ShortByReference src, IntByReference consumed, int src_size, int dst_size, int update_ctx);
    /** Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code> */
    int av_resample(LibavcodecLibrary.AVResampleContext c, ShortBuffer dst, ShortBuffer src, IntBuffer consumed, int src_size, int dst_size, int update_ctx);
    /** Original signature : <code>void av_resample_compensate(AVResampleContext*, int, int)</code> */
    void av_resample_compensate(LibavcodecLibrary.AVResampleContext c, int sample_delta, int compensation_distance);
    /** Original signature : <code>void av_resample_close(AVResampleContext*)</code> */
    void av_resample_close(LibavcodecLibrary.AVResampleContext c);
    /**
     * Allocate memory for a picture.  Call avpicture_free() to free it.<br>
     * * @see avpicture_fill()<br>
     * * @param picture the picture to be filled in<br>
     * @param pix_fmt the format of the picture<br>
     * @param width the width of the picture<br>
     * @param height the height of the picture<br>
     * @return zero if successful, a negative value if not<br>
     * Original signature : <code>int avpicture_alloc(AVPicture*, AVPixelFormat, int, int)</code>
     */
    int avpicture_alloc(AVPicture picture, int pix_fmt, int width, int height);
    /**
     * Free a picture previously allocated by avpicture_alloc().<br>
     * The data buffer used by the AVPicture is freed, but the AVPicture structure<br>
     * itself is not.<br>
     * * @param picture the AVPicture to be freed<br>
     * Original signature : <code>void avpicture_free(AVPicture*)</code>
     */
    void avpicture_free(AVPicture picture);
    /**
     * Fill in the AVPicture fields, always assume a linesize alignment of<br>
     * 1.<br>
     * * @see av_image_fill_arrays()<br>
     * Original signature : <code>int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)</code><br>
     * @deprecated use the safer methods {@link #avpicture_fill(org.javaavc.gen.avcodec.AVPicture, java.nio.ByteBuffer, int, int, int)} and {@link #avpicture_fill(org.javaavc.gen.avcodec.AVPicture, com.sun.jna.Pointer, int, int, int)} instead
     */
    @Deprecated
    int avpicture_fill(AVPicture picture, Pointer ptr, int pix_fmt, int width, int height);
    /**
     * Fill in the AVPicture fields, always assume a linesize alignment of<br>
     * 1.<br>
     * * @see av_image_fill_arrays()<br>
     * Original signature : <code>int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)</code>
     */
    int avpicture_fill(AVPicture picture, ByteBuffer ptr, int pix_fmt, int width, int height);
    /**
     * Copy pixel data from an AVPicture into a buffer, always assume a<br>
     * linesize alignment of 1.<br>
     * * @see av_image_copy_to_buffer()<br>
     * Original signature : <code>int avpicture_layout(const AVPicture*, AVPixelFormat, int, int, unsigned char*, int)</code><br>
     * @deprecated use the safer methods {@link #avpicture_layout(org.javaavc.gen.avcodec.AVPicture, int, int, int, java.nio.ByteBuffer, int)} and {@link #avpicture_layout(org.javaavc.gen.avcodec.AVPicture, int, int, int, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int avpicture_layout(AVPicture src, int pix_fmt, int width, int height, Pointer dest, int dest_size);
    /**
     * Copy pixel data from an AVPicture into a buffer, always assume a<br>
     * linesize alignment of 1.<br>
     * * @see av_image_copy_to_buffer()<br>
     * Original signature : <code>int avpicture_layout(const AVPicture*, AVPixelFormat, int, int, unsigned char*, int)</code>
     */
    int avpicture_layout(AVPicture src, int pix_fmt, int width, int height, ByteBuffer dest, int dest_size);
    /**
     * Calculate the size in bytes that a picture of the given width and height<br>
     * would occupy if stored in the given picture format.<br>
     * Always assume a linesize alignment of 1.<br>
     * * @see av_image_get_buffer_size().<br>
     * Original signature : <code>int avpicture_get_size(AVPixelFormat, int, int)</code>
     */
    int avpicture_get_size(int pix_fmt, int width, int height);
    /** Original signature : <code>int avpicture_deinterlace(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code> */
    int avpicture_deinterlace(AVPicture dst, AVPicture src, int pix_fmt, int width, int height);
    /**
     * Copy image src to dst. Wraps av_image_copy().<br>
     * Original signature : <code>void av_picture_copy(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code>
     */
    void av_picture_copy(AVPicture dst, AVPicture src, int pix_fmt, int width, int height);
    /**
     * Crop image top and left side.<br>
     * Original signature : <code>int av_picture_crop(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code>
     */
    int av_picture_crop(AVPicture dst, AVPicture src, int pix_fmt, int top_band, int left_band);
    /**
     * Pad image.<br>
     * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, AVPixelFormat, int, int, int, int, int*)</code><br>
     * @deprecated use the safer methods {@link #av_picture_pad(org.javaavc.gen.avcodec.AVPicture, org.javaavc.gen.avcodec.AVPicture, int, int, int, int, int, int, int, java.nio.IntBuffer)} and {@link #av_picture_pad(org.javaavc.gen.avcodec.AVPicture, org.javaavc.gen.avcodec.AVPicture, int, int, int, int, int, int, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int av_picture_pad(AVPicture dst, AVPicture src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, IntByReference color);
    /**
     * Pad image.<br>
     * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, AVPixelFormat, int, int, int, int, int*)</code>
     */
    int av_picture_pad(AVPicture dst, AVPicture src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, IntBuffer color);
    /**
     * Original signature : <code>void avcodec_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_get_chroma_sub_sample(int, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_get_chroma_sub_sample(int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    void avcodec_get_chroma_sub_sample(int pix_fmt, IntByReference h_shift, IntByReference v_shift);
    /** Original signature : <code>void avcodec_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code> */
    void avcodec_get_chroma_sub_sample(int pix_fmt, IntBuffer h_shift, IntBuffer v_shift);
    /**
     * Return a value representing the fourCC code associated to the<br>
     * pixel format pix_fmt, or 0 if no associated fourCC code can be<br>
     * found.<br>
     * Original signature : <code>int avcodec_pix_fmt_to_codec_tag(AVPixelFormat)</code>
     */
    int avcodec_pix_fmt_to_codec_tag(int pix_fmt);
    /**
     * Compute what kind of losses will occur when converting from one specific<br>
     * pixel format to another.<br>
     * When converting from one pixel format to another, information loss may occur.<br>
     * For example, when converting from RGB24 to GRAY, the color information will<br>
     * be lost. Similarly, other losses occur when converting from some formats to<br>
     * other formats. These losses can involve loss of chroma, but also loss of<br>
     * resolution, loss of color depth, loss due to the color space conversion, loss<br>
     * of the alpha bits or loss due to color quantization.<br>
     * avcodec_get_fix_fmt_loss() informs you about the various types of losses<br>
     * which will occur when converting from one pixel format to another.<br>
     * * @param[in] dst_pix_fmt destination pixel format<br>
     * @param[in] src_pix_fmt source pixel format<br>
     * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
     * @return Combination of flags informing you what kind of losses will occur<br>
     * (maximum loss for an invalid dst_pix_fmt).<br>
     * Original signature : <code>int avcodec_get_pix_fmt_loss(AVPixelFormat, AVPixelFormat, int)</code>
     */
    int avcodec_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha);
    /**
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt(int64_t, AVPixelFormat, int, int*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt(long, int, int, java.nio.IntBuffer)} and {@link #avcodec_find_best_pix_fmt(long, int, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int avcodec_find_best_pix_fmt(long pix_fmt_mask, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
    /** Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt(int64_t, AVPixelFormat, int, int*)</code> */
    int avcodec_find_best_pix_fmt(long pix_fmt_mask, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
    /**
     * Find the best pixel format to convert to given a certain source pixel<br>
     * format.  When converting from one pixel format to another, information loss<br>
     * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
     * information will be lost. Similarly, other losses occur when converting from<br>
     * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of<br>
     * the given pixel formats should be used to suffer the least amount of loss.<br>
     * The pixel formats from which it chooses one, are determined by the<br>
     * pix_fmt_list parameter.<br>
     * *<br>
     * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from<br>
     * @param[in] src_pix_fmt source pixel format<br>
     * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
     * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
     * @return The best pixel format to convert to or -1 if none was found.<br>
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_list(AVPixelFormat*, AVPixelFormat, int, int*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt_of_list(java.nio.IntBuffer, int, int, java.nio.IntBuffer)} and {@link #avcodec_find_best_pix_fmt_of_list(com.sun.jna.ptr.IntByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int avcodec_find_best_pix_fmt_of_list(IntByReference pix_fmt_list, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
    /**
     * Find the best pixel format to convert to given a certain source pixel<br>
     * format.  When converting from one pixel format to another, information loss<br>
     * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
     * information will be lost. Similarly, other losses occur when converting from<br>
     * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of<br>
     * the given pixel formats should be used to suffer the least amount of loss.<br>
     * The pixel formats from which it chooses one, are determined by the<br>
     * pix_fmt_list parameter.<br>
     * *<br>
     * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from<br>
     * @param[in] src_pix_fmt source pixel format<br>
     * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
     * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
     * @return The best pixel format to convert to or -1 if none was found.<br>
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_list(AVPixelFormat*, AVPixelFormat, int, int*)</code>
     */
    int avcodec_find_best_pix_fmt_of_list(IntBuffer pix_fmt_list, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
    /**
     * Find the best pixel format to convert to given a certain source pixel<br>
     * format and a selection of two destination pixel formats. When converting from<br>
     * one pixel format to another, information loss may occur.  For example, when converting<br>
     * from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when<br>
     * converting from some formats to other formats. avcodec_find_best_pix_fmt_of_2() selects which of<br>
     * the given pixel formats should be used to suffer the least amount of loss.<br>
     * * If one of the destination formats is AV_PIX_FMT_NONE the other pixel format (if valid) will be<br>
     * returned.<br>
     * * @code<br>
     * src_pix_fmt = AV_PIX_FMT_YUV420P;<br>
     * dst_pix_fmt1= AV_PIX_FMT_RGB24;<br>
     * dst_pix_fmt2= AV_PIX_FMT_GRAY8;<br>
     * dst_pix_fmt3= AV_PIX_FMT_RGB8;<br>
     * loss= FF_LOSS_CHROMA; // don't care about chroma loss, so chroma loss will be ignored.<br>
     * dst_pix_fmt = avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, alpha, &loss);<br>
     * dst_pix_fmt = avcodec_find_best_pix_fmt_of_2(dst_pix_fmt, dst_pix_fmt3, src_pix_fmt, alpha, &loss);<br>
     * @endcode<br>
     * * @param[in] dst_pix_fmt1 One of the two destination pixel formats to choose from<br>
     * @param[in] dst_pix_fmt2 The other of the two destination pixel formats to choose from<br>
     * @param[in] src_pix_fmt Source pixel format<br>
     * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
     * @param[in, out] loss_ptr Combination of loss flags. In: selects which of the losses to ignore, i.e.<br>
     *                               NULL or value of zero means we care about all losses. Out: the loss<br>
     *                               that occurs when converting from src to selected dst pixel format.<br>
     * @return The best pixel format to convert to or -1 if none was found.<br>
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt_of_2(int, int, int, int, java.nio.IntBuffer)} and {@link #avcodec_find_best_pix_fmt_of_2(int, int, int, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int avcodec_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
    /**
     * Find the best pixel format to convert to given a certain source pixel<br>
     * format and a selection of two destination pixel formats. When converting from<br>
     * one pixel format to another, information loss may occur.  For example, when converting<br>
     * from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when<br>
     * converting from some formats to other formats. avcodec_find_best_pix_fmt_of_2() selects which of<br>
     * the given pixel formats should be used to suffer the least amount of loss.<br>
     * * If one of the destination formats is AV_PIX_FMT_NONE the other pixel format (if valid) will be<br>
     * returned.<br>
     * * @code<br>
     * src_pix_fmt = AV_PIX_FMT_YUV420P;<br>
     * dst_pix_fmt1= AV_PIX_FMT_RGB24;<br>
     * dst_pix_fmt2= AV_PIX_FMT_GRAY8;<br>
     * dst_pix_fmt3= AV_PIX_FMT_RGB8;<br>
     * loss= FF_LOSS_CHROMA; // don't care about chroma loss, so chroma loss will be ignored.<br>
     * dst_pix_fmt = avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, alpha, &loss);<br>
     * dst_pix_fmt = avcodec_find_best_pix_fmt_of_2(dst_pix_fmt, dst_pix_fmt3, src_pix_fmt, alpha, &loss);<br>
     * @endcode<br>
     * * @param[in] dst_pix_fmt1 One of the two destination pixel formats to choose from<br>
     * @param[in] dst_pix_fmt2 The other of the two destination pixel formats to choose from<br>
     * @param[in] src_pix_fmt Source pixel format<br>
     * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
     * @param[in, out] loss_ptr Combination of loss flags. In: selects which of the losses to ignore, i.e.<br>
     *                               NULL or value of zero means we care about all losses. Out: the loss<br>
     *                               that occurs when converting from src to selected dst pixel format.<br>
     * @return The best pixel format to convert to or -1 if none was found.<br>
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code>
     */
    int avcodec_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
    /**
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt2(int, int, int, int, java.nio.IntBuffer)} and {@link #avcodec_find_best_pix_fmt2(int, int, int, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int avcodec_find_best_pix_fmt2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
    /** Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code> */
    int avcodec_find_best_pix_fmt2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
    /**
     * Original signature : <code>AVPixelFormat avcodec_default_get_format(AVCodecContext*, AVPixelFormat*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_default_get_format(org.javaavc.gen.avcodec.AVCodecContext, java.nio.IntBuffer)} and {@link #avcodec_default_get_format(org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int avcodec_default_get_format(AVCodecContext s, IntByReference fmt);
    /** Original signature : <code>AVPixelFormat avcodec_default_get_format(AVCodecContext*, AVPixelFormat*)</code> */
    int avcodec_default_get_format(AVCodecContext s, IntBuffer fmt);
    /** Original signature : <code>void avcodec_set_dimensions(AVCodecContext*, int, int)</code> */
    void avcodec_set_dimensions(AVCodecContext s, int width, int height);
    /**
     * Put a string representing the codec tag codec_tag in buf.<br>
     * * @param buf_size size in bytes of buf<br>
     * @return the length of the string that would have been generated if<br>
     * enough space had been available, excluding the trailing null<br>
     * Original signature : <code>size_t av_get_codec_tag_string(char*, size_t, unsigned int)</code><br>
     * @deprecated use the safer methods {@link #av_get_codec_tag_string(java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize, int)} and {@link #av_get_codec_tag_string(com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize, int)} instead
     */
    @Deprecated
    NativeSize av_get_codec_tag_string(Pointer buf, NativeSize buf_size, int codec_tag);
    /**
     * Put a string representing the codec tag codec_tag in buf.<br>
     * * @param buf_size size in bytes of buf<br>
     * @return the length of the string that would have been generated if<br>
     * enough space had been available, excluding the trailing null<br>
     * Original signature : <code>size_t av_get_codec_tag_string(char*, size_t, unsigned int)</code>
     */
    NativeSize av_get_codec_tag_string(ByteBuffer buf, NativeSize buf_size, int codec_tag);
    /**
     * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
     * @deprecated use the safer methods {@link #avcodec_string(java.nio.ByteBuffer, int, org.javaavc.gen.avcodec.AVCodecContext, int)} and {@link #avcodec_string(com.sun.jna.Pointer, int, org.javaavc.gen.avcodec.AVCodecContext, int)} instead
     */
    @Deprecated
    void avcodec_string(Pointer buf, int buf_size, AVCodecContext enc, int encode);
    /** Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code> */
    void avcodec_string(ByteBuffer buf, int buf_size, AVCodecContext enc, int encode);
    /**
     * Return a name for the specified profile, if available.<br>
     * * @param codec the codec that is searched for the given profile<br>
     * @param profile the profile value for which a name is requested<br>
     * @return A name for the profile if found, NULL otherwise.<br>
     * Original signature : <code>char* av_get_profile_name(const AVCodec*, int)</code>
     */
    String av_get_profile_name(AVCodec codec, int profile);
    /**
     * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_func_callback*, void*, int*, int, int)</code><br>
     * @deprecated use the safer methods {@link #avcodec_default_execute(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.LibavcodecLibrary.avcodec_default_execute_func_callback, com.sun.jna.Pointer, java.nio.IntBuffer, int, int)} and {@link #avcodec_default_execute(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.LibavcodecLibrary.avcodec_default_execute_func_callback, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int, int)} instead
     */
    @Deprecated
    int avcodec_default_execute(AVCodecContext c, LibavcodecLibrary.avcodec_default_execute_func_callback func, Pointer arg, IntByReference ret, int count, int size);
    /** Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_func_callback*, void*, int*, int, int)</code> */
    int avcodec_default_execute(AVCodecContext c, LibavcodecLibrary.avcodec_default_execute_func_callback func, Pointer arg, IntBuffer ret, int count, int size);
    /**
     * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_func_callback*, void*, int*, int)</code><br>
     * @deprecated use the safer methods {@link #avcodec_default_execute2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.LibavcodecLibrary.avcodec_default_execute2_func_callback, com.sun.jna.Pointer, java.nio.IntBuffer, int)} and {@link #avcodec_default_execute2(org.javaavc.gen.avcodec.AVCodecContext, org.javaavc.gen.avcodec.LibavcodecLibrary.avcodec_default_execute2_func_callback, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int)} instead
     */
    @Deprecated
    int avcodec_default_execute2(AVCodecContext c, LibavcodecLibrary.avcodec_default_execute2_func_callback func, Pointer arg, IntByReference ret, int count);
    /** Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_func_callback*, void*, int*, int)</code> */
    int avcodec_default_execute2(AVCodecContext c, LibavcodecLibrary.avcodec_default_execute2_func_callback func, Pointer arg, IntBuffer ret, int count);
    /**
     * Fill AVFrame audio data and linesize pointers.<br>
     * * The buffer buf must be a preallocated buffer with a size big enough<br>
     * to contain the specified samples amount. The filled AVFrame data<br>
     * pointers will point to this buffer.<br>
     * * AVFrame extended_data channel pointers are allocated if necessary for<br>
     * planar audio.<br>
     * * @param frame       the AVFrame<br>
     *                    frame->nb_samples must be set prior to calling the<br>
     *                    function. This function fills in frame->data,<br>
     *                    frame->extended_data, frame->linesize[0].<br>
     * @param nb_channels channel count<br>
     * @param sample_fmt  sample format<br>
     * @param buf         buffer to use for frame data<br>
     * @param buf_size    size of buffer<br>
     * @param align       plane size sample alignment (0 = default)<br>
     * @return            >=0 on success, negative error code on failure<br>
     * @todo return the size in bytes required to store the samples in<br>
     * case of success, at the next libavutil bump<br>
     * Original signature : <code>int avcodec_fill_audio_frame(AVFrame*, int, AVSampleFormat, const uint8_t*, int, int)</code><br>
     * @deprecated use the safer methods {@link #avcodec_fill_audio_frame(org.javaavc.gen.avcodec.AVFrame, int, org.javaavc.gen.avcodec.LibavcodecLibrary.AVSampleFormat, java.nio.ByteBuffer, int, int)} and {@link #avcodec_fill_audio_frame(org.javaavc.gen.avcodec.AVFrame, int, org.javaavc.gen.avcodec.LibavcodecLibrary.AVSampleFormat, com.sun.jna.Pointer, int, int)} instead
     */
    @Deprecated
    int avcodec_fill_audio_frame(AVFrame frame, int nb_channels, LibavcodecLibrary.AVSampleFormat sample_fmt, Pointer buf, int buf_size, int align);
    /**
     * Fill AVFrame audio data and linesize pointers.<br>
     * * The buffer buf must be a preallocated buffer with a size big enough<br>
     * to contain the specified samples amount. The filled AVFrame data<br>
     * pointers will point to this buffer.<br>
     * * AVFrame extended_data channel pointers are allocated if necessary for<br>
     * planar audio.<br>
     * * @param frame       the AVFrame<br>
     *                    frame->nb_samples must be set prior to calling the<br>
     *                    function. This function fills in frame->data,<br>
     *                    frame->extended_data, frame->linesize[0].<br>
     * @param nb_channels channel count<br>
     * @param sample_fmt  sample format<br>
     * @param buf         buffer to use for frame data<br>
     * @param buf_size    size of buffer<br>
     * @param align       plane size sample alignment (0 = default)<br>
     * @return            >=0 on success, negative error code on failure<br>
     * @todo return the size in bytes required to store the samples in<br>
     * case of success, at the next libavutil bump<br>
     * Original signature : <code>int avcodec_fill_audio_frame(AVFrame*, int, AVSampleFormat, const uint8_t*, int, int)</code>
     */
    int avcodec_fill_audio_frame(AVFrame frame, int nb_channels, LibavcodecLibrary.AVSampleFormat sample_fmt, ByteBuffer buf, int buf_size, int align);
    /**
     * Flush buffers, should be called when seeking or when switching to a different stream.<br>
     * Original signature : <code>void avcodec_flush_buffers(AVCodecContext*)</code>
     */
    void avcodec_flush_buffers(AVCodecContext avctx);
    /** Original signature : <code>void avcodec_default_free_buffers(AVCodecContext*)</code> */
    void avcodec_default_free_buffers(AVCodecContext s);
    /**
     * Return codec bits per sample.<br>
     * * @param[in] codec_id the codec<br>
     * @return Number of bits per sample or zero if unknown for the given codec.<br>
     * Original signature : <code>int av_get_bits_per_sample(AVCodecID)</code>
     */
    int av_get_bits_per_sample(int codec_id);
    /**
     * Return the PCM codec associated with a sample format.<br>
     * @param be  endianness, 0 for little, 1 for big,<br>
     *            -1 (or anything else) for native<br>
     * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE<br>
     * Original signature : <code>AVCodecID av_get_pcm_codec(AVSampleFormat, int)</code>
     */
    int av_get_pcm_codec(LibavcodecLibrary.AVSampleFormat fmt, int be);
    /**
     * Return codec bits per sample.<br>
     * Only return non-zero if the bits per sample is exactly correct, not an<br>
     * approximation.<br>
     * * @param[in] codec_id the codec<br>
     * @return Number of bits per sample or zero if unknown for the given codec.<br>
     * Original signature : <code>int av_get_exact_bits_per_sample(AVCodecID)</code>
     */
    int av_get_exact_bits_per_sample(int codec_id);
    /**
     * Return audio frame duration.<br>
     * * @param avctx        codec context<br>
     * @param frame_bytes  size of the frame, or 0 if unknown<br>
     * @return             frame duration, in samples, if known. 0 if not able to<br>
     *                     determine.<br>
     * Original signature : <code>int av_get_audio_frame_duration(AVCodecContext*, int)</code>
     */
    int av_get_audio_frame_duration(AVCodecContext avctx, int frame_bytes);
    /** Original signature : <code>void av_register_bitstream_filter(AVBitStreamFilter*)</code> */
    void av_register_bitstream_filter(AVBitStreamFilter bsf);
    /**
     * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
     * @deprecated use the safer methods {@link #av_bitstream_filter_init(java.lang.String)} and {@link #av_bitstream_filter_init(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    AVBitStreamFilterContext av_bitstream_filter_init(Pointer name);
    /** Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code> */
    AVBitStreamFilterContext av_bitstream_filter_init(String name);
    /**
     * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
     * @deprecated use the safer methods {@link #av_bitstream_filter_filter(org.javaavc.gen.avcodec.AVBitStreamFilterContext, org.javaavc.gen.avcodec.AVCodecContext, java.lang.String, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.ByteBuffer, int, int)} and {@link #av_bitstream_filter_filter(org.javaavc.gen.avcodec.AVBitStreamFilterContext, org.javaavc.gen.avcodec.AVCodecContext, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, int)} instead
     */
    @Deprecated
    int av_bitstream_filter_filter(AVBitStreamFilterContext bsfc, AVCodecContext avctx, Pointer args, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, int keyframe);
    /** Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code> */
    int av_bitstream_filter_filter(AVBitStreamFilterContext bsfc, AVCodecContext avctx, String args, PointerByReference poutbuf, IntBuffer poutbuf_size, ByteBuffer buf, int buf_size, int keyframe);
    /** Original signature : <code>void av_bitstream_filter_close(AVBitStreamFilterContext*)</code> */
    void av_bitstream_filter_close(AVBitStreamFilterContext bsf);
    /** Original signature : <code>AVBitStreamFilter* av_bitstream_filter_next(AVBitStreamFilter*)</code> */
    AVBitStreamFilter av_bitstream_filter_next(AVBitStreamFilter f);
    /**
     * Reallocate the given block if it is not large enough, otherwise do nothing.<br>
     * * @see av_realloc<br>
     * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, size_t)</code><br>
     * @deprecated use the safer methods {@link #av_fast_realloc(com.sun.jna.Pointer, java.nio.IntBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #av_fast_realloc(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
     */
    @Deprecated
    Pointer av_fast_realloc(Pointer ptr, IntByReference size, NativeSize min_size);
    /**
     * Reallocate the given block if it is not large enough, otherwise do nothing.<br>
     * * @see av_realloc<br>
     * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, size_t)</code>
     */
    Pointer av_fast_realloc(Pointer ptr, IntBuffer size, NativeSize min_size);
    /**
     * Allocate a buffer, reusing the given one if large enough.<br>
     * * Contrary to av_fast_realloc the current buffer contents might not be<br>
     * preserved and on error the old buffer is freed, thus no special<br>
     * handling to avoid memleaks is necessary.<br>
     * * @param ptr pointer to pointer to already allocated buffer, overwritten with pointer to new buffer<br>
     * @param size size of the buffer *ptr points to<br>
     * @param min_size minimum size of *ptr buffer after returning, *ptr will be NULL and<br>
     *                 *size 0 if an error occurred.<br>
     * Original signature : <code>void av_fast_malloc(void*, unsigned int*, size_t)</code><br>
     * @deprecated use the safer methods {@link #av_fast_malloc(com.sun.jna.Pointer, java.nio.IntBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #av_fast_malloc(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
     */
    @Deprecated
    void av_fast_malloc(Pointer ptr, IntByReference size, NativeSize min_size);
    /**
     * Allocate a buffer, reusing the given one if large enough.<br>
     * * Contrary to av_fast_realloc the current buffer contents might not be<br>
     * preserved and on error the old buffer is freed, thus no special<br>
     * handling to avoid memleaks is necessary.<br>
     * * @param ptr pointer to pointer to already allocated buffer, overwritten with pointer to new buffer<br>
     * @param size size of the buffer *ptr points to<br>
     * @param min_size minimum size of *ptr buffer after returning, *ptr will be NULL and<br>
     *                 *size 0 if an error occurred.<br>
     * Original signature : <code>void av_fast_malloc(void*, unsigned int*, size_t)</code>
     */
    void av_fast_malloc(Pointer ptr, IntBuffer size, NativeSize min_size);
    /**
     * Same behaviour av_fast_malloc but the buffer has additional<br>
     * FF_INPUT_BUFFER_PADDING_SIZE at the end which will will always be 0.<br>
     * * In addition the whole buffer will initially and after resizes<br>
     * be 0-initialized so that no uninitialized data will ever appear.<br>
     * Original signature : <code>void av_fast_padded_malloc(void*, unsigned int*, size_t)</code><br>
     * @deprecated use the safer methods {@link #av_fast_padded_malloc(com.sun.jna.Pointer, java.nio.IntBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #av_fast_padded_malloc(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
     */
    @Deprecated
    void av_fast_padded_malloc(Pointer ptr, IntByReference size, NativeSize min_size);
    /**
     * Same behaviour av_fast_malloc but the buffer has additional<br>
     * FF_INPUT_BUFFER_PADDING_SIZE at the end which will will always be 0.<br>
     * * In addition the whole buffer will initially and after resizes<br>
     * be 0-initialized so that no uninitialized data will ever appear.<br>
     * Original signature : <code>void av_fast_padded_malloc(void*, unsigned int*, size_t)</code>
     */
    void av_fast_padded_malloc(Pointer ptr, IntBuffer size, NativeSize min_size);
    /**
     * Same behaviour av_fast_padded_malloc except that buffer will always<br>
     * be 0-initialized after call.<br>
     * Original signature : <code>void av_fast_padded_mallocz(void*, unsigned int*, size_t)</code><br>
     * @deprecated use the safer methods {@link #av_fast_padded_mallocz(com.sun.jna.Pointer, java.nio.IntBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #av_fast_padded_mallocz(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
     */
    @Deprecated
    void av_fast_padded_mallocz(Pointer ptr, IntByReference size, NativeSize min_size);
    /**
     * Same behaviour av_fast_padded_malloc except that buffer will always<br>
     * be 0-initialized after call.<br>
     * Original signature : <code>void av_fast_padded_mallocz(void*, unsigned int*, size_t)</code>
     */
    void av_fast_padded_mallocz(Pointer ptr, IntBuffer size, NativeSize min_size);
    /**
     * Encode extradata length to a buffer. Used by xiph codecs.<br>
     * * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
     * @param v size of extradata in bytes<br>
     * @return number of bytes written to the buffer.<br>
     * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
     * @deprecated use the safer methods {@link #av_xiphlacing(java.nio.ByteBuffer, int)} and {@link #av_xiphlacing(com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int av_xiphlacing(Pointer s, int v);
    /**
     * Encode extradata length to a buffer. Used by xiph codecs.<br>
     * * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
     * @param v size of extradata in bytes<br>
     * @return number of bytes written to the buffer.<br>
     * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code>
     */
    int av_xiphlacing(ByteBuffer s, int v);
    /**
     * Log a generic warning message about a missing feature. This function is<br>
     * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
     * only, and would normally not be used by applications.<br>
     * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
     * a pointer to an AVClass struct<br>
     * @param[in] feature string containing the name of the missing feature<br>
     * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
     * If want_sample is non-zero, additional verbage will be added to the log<br>
     * message which tells the user how to report samples to the development<br>
     * mailing list.<br>
     * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code><br>
     * @deprecated use the safer methods {@link #av_log_missing_feature(com.sun.jna.Pointer, java.lang.String, int)} and {@link #av_log_missing_feature(com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    void av_log_missing_feature(Pointer avc, Pointer feature, int want_sample);
    /**
     * Log a generic warning message about a missing feature. This function is<br>
     * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
     * only, and would normally not be used by applications.<br>
     * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
     * a pointer to an AVClass struct<br>
     * @param[in] feature string containing the name of the missing feature<br>
     * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
     * If want_sample is non-zero, additional verbage will be added to the log<br>
     * message which tells the user how to report samples to the development<br>
     * mailing list.<br>
     * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code>
     */
    void av_log_missing_feature(Pointer avc, String feature, int want_sample);
    /**
     * Log a generic warning message asking for a sample. This function is<br>
     * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
     * only, and would normally not be used by applications.<br>
     * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
     * a pointer to an AVClass struct<br>
     * @param[in] msg string containing an optional message, or NULL if no message<br>
     * Original signature : <code>void av_log_ask_for_sample(void*, const char*, null)</code><br>
     * @deprecated use the safer methods {@link #av_log_ask_for_sample(com.sun.jna.Pointer, java.lang.String, java.lang.Object)} and {@link #av_log_ask_for_sample(com.sun.jna.Pointer, com.sun.jna.Pointer, java.lang.Object)} instead
     */
    @Deprecated
    void av_log_ask_for_sample(Pointer avc, Pointer msg, Object... varargs);
    /**
     * Log a generic warning message asking for a sample. This function is<br>
     * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
     * only, and would normally not be used by applications.<br>
     * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
     * a pointer to an AVClass struct<br>
     * @param[in] msg string containing an optional message, or NULL if no message<br>
     * Original signature : <code>void av_log_ask_for_sample(void*, const char*, null)</code>
     */
    void av_log_ask_for_sample(Pointer avc, String msg, Object... varargs);
    /**
     * Register the hardware accelerator hwaccel.<br>
     * Original signature : <code>void av_register_hwaccel(AVHWAccel*)</code>
     */
    void av_register_hwaccel(AVHWAccel hwaccel);
    /**
     * If hwaccel is NULL, returns the first registered hardware accelerator,<br>
     * if hwaccel is non-NULL, returns the next registered hardware accelerator<br>
     * after hwaccel, or NULL if hwaccel is the last one.<br>
     * Original signature : <code>AVHWAccel* av_hwaccel_next(AVHWAccel*)</code>
     */
    AVHWAccel av_hwaccel_next(AVHWAccel hwaccel);
    /**
     * Register a user provided lock manager supporting the operations<br>
     * specified by AVLockOp. mutex points to a (void *) where the<br>
     * lockmgr should store/get a pointer to a user allocated mutex. It's<br>
     * NULL upon AV_LOCK_CREATE and != NULL for all other ops.<br>
     * * @param cb User defined callback. Note: FFmpeg may invoke calls to this<br>
     *           callback during the call to av_lockmgr_register().<br>
     *           Thus, the application must be prepared to handle that.<br>
     *           If cb is set to NULL the lockmgr will be unregistered.<br>
     *           Also note that during unregistration the previously registered<br>
     *           lockmgr callback may also be invoked.<br>
     * Original signature : <code>int av_lockmgr_register(av_lockmgr_register_cb_callback*)</code>
     */
    int av_lockmgr_register(LibavcodecLibrary.av_lockmgr_register_cb_callback cb);
    /**
     * Get the type of the given codec.<br>
     * Original signature : <code>AVMediaType avcodec_get_type(AVCodecID)</code>
     */
    LibavcodecLibrary.AVMediaType avcodec_get_type(int codec_id);
    /**
     * Get the name of a codec.<br>
     * @return  a static string identifying the codec; never NULL<br>
     * Original signature : <code>char* avcodec_get_name(AVCodecID)</code>
     */
    String avcodec_get_name(int id);
    /**
     * @return a positive value if s is open (i.e. avcodec_open2() was called on it<br>
     * with no corresponding avcodec_close()), 0 otherwise.<br>
     * Original signature : <code>int avcodec_is_open(AVCodecContext*)</code>
     */
    int avcodec_is_open(AVCodecContext s);
    /**
     * @return a non-zero number if codec is an encoder, zero otherwise<br>
     * Original signature : <code>int av_codec_is_encoder(const AVCodec*)</code>
     */
    int av_codec_is_encoder(AVCodec codec);
    /**
     * @return a non-zero number if codec is a decoder, zero otherwise<br>
     * Original signature : <code>int av_codec_is_decoder(const AVCodec*)</code>
     */
    int av_codec_is_decoder(AVCodec codec);
    /**
     * @return descriptor for given codec ID or NULL if no descriptor exists.<br>
     * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get(AVCodecID)</code>
     */
    AVCodecDescriptor avcodec_descriptor_get(int id);
    /**
     * Iterate over all codec descriptors known to libavcodec.<br>
     * * @param prev previous descriptor. NULL to get the first descriptor.<br>
     * * @return next descriptor or NULL after the last descriptor<br>
     * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_next(const AVCodecDescriptor*)</code>
     */
    AVCodecDescriptor avcodec_descriptor_next(AVCodecDescriptor prev);
    /**
     * @return codec descriptor with the given name or NULL if no such descriptor<br>
     *         exists.<br>
     * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get_by_name(const char*)</code><br>
     * @deprecated use the safer methods {@link #avcodec_descriptor_get_by_name(java.lang.String)} and {@link #avcodec_descriptor_get_by_name(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    AVCodecDescriptor avcodec_descriptor_get_by_name(Pointer name);
    /**
     * @return codec descriptor with the given name or NULL if no such descriptor<br>
     *         exists.<br>
     * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get_by_name(const char*)</code>
     */
    AVCodecDescriptor avcodec_descriptor_get_by_name(String name);
    public static class AVCodecInternal extends PointerType {
        public AVCodecInternal(Pointer address) {
            super(address);
        }
        public AVCodecInternal() {
            super();
        }
    };
    public static class AVMediaType extends PointerType {
        public AVMediaType(Pointer address) {
            super(address);
        }
        public AVMediaType() {
            super();
        }
    };
    public static class AVCodecDefault extends PointerType {
        public AVCodecDefault(Pointer address) {
            super(address);
        }
        public AVCodecDefault() {
            super();
        }
    };
    public static class AVResampleContext extends PointerType {
        public AVResampleContext(Pointer address) {
            super(address);
        }
        public AVResampleContext() {
            super();
        }
    };
    public static class AVSampleFormat extends PointerType {
        public AVSampleFormat(Pointer address) {
            super(address);
        }
        public AVSampleFormat() {
            super();
        }
    };
    public static class AVPictureType extends PointerType {
        public AVPictureType(Pointer address) {
            super(address);
        }
        public AVPictureType() {
            super();
        }
    };
    public static class AVDictionary extends PointerType {
        public AVDictionary(Pointer address) {
            super(address);
        }
        public AVDictionary() {
            super();
        }
    };
    public static class ReSampleContext extends PointerType {
        public ReSampleContext(Pointer address) {
            super(address);
        }
        public ReSampleContext() {
            super();
        }
    };
}
