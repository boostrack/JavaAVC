package org.javaavc.gen.avfilter;
import com.sun.jna.Callback;
import com.sun.jna.Pointer;
import com.sun.jna.Structure;
import java.util.Arrays;
import java.util.List;
import org.javaavc.gen.avfilter.LibavfilterLibrary.AVClass;
/**
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class AVFilter extends Structure {
	/**
	 * < filter name<br>
	 * C type : const char*
	 */
	public Pointer name;
	/**
	 * A description for the filter. You should use the<br>
	 * NULL_IF_CONFIG_SMALL() macro to define it.<br>
	 * C type : const char*
	 */
	public Pointer description;
	/**
	 * < NULL terminated list of inputs. NULL if none<br>
	 * C type : const AVFilterPad*
	 */
	public org.javaavc.gen.avfilter.AVFilterPad.ByReference inputs;
	/**
	 * < NULL terminated list of outputs. NULL if none<br>
	 * C type : const AVFilterPad*
	 */
	public org.javaavc.gen.avfilter.AVFilterPad.ByReference outputs;
	/**
	 * Filter initialization function. Args contains the user-supplied<br>
	 * parameters. FIXME: maybe an AVOption-based system would be better?<br>
	 * C type : init_callback*
	 */
	public AVFilter.init_callback init;
	/**
	 * Filter uninitialization function. Should deallocate any memory held<br>
	 * by the filter, release any buffer references, etc. This does not need<br>
	 * to deallocate the AVFilterContext->priv memory itself.<br>
	 * C type : uninit_callback*
	 */
	public AVFilter.uninit_callback uninit;
	/**
	 * Queries formats/layouts supported by the filter and its pads, and sets<br>
	 * the in_formats/in_chlayouts for links connected to its output pads,<br>
	 * and out_formats/out_chlayouts for links connected to its input pads.<br>
	 * * @return zero on success, a negative value corresponding to an<br>
	 * AVERROR code otherwise<br>
	 * C type : query_formats_callback*
	 */
	public AVFilter.query_formats_callback query_formats;
	/** < size of private data to allocate for the filter */
	public int priv_size;
	/**
	 * Make the filter instance process a command.<br>
	 * * @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only<br>
	 * @param arg    the argument for the command<br>
	 * @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported.<br>
	 * @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be<br>
	 *               time consuming then a filter should treat it like an unsupported command<br>
	 * * @returns >=0 on success otherwise an error code.<br>
	 *          AVERROR(ENOSYS) on unsupported commands<br>
	 * C type : process_command_callback*
	 */
	public AVFilter.process_command_callback process_command;
	/**
	 * Filter initialization function, alternative to the init()<br>
	 * callback. Args contains the user-supplied parameters, opaque is<br>
	 * used for providing binary data.<br>
	 * C type : init_opaque_callback*
	 */
	public AVFilter.init_opaque_callback init_opaque;
	/**
	 * < private class, containing filter specific options<br>
	 * C type : const AVClass*
	 */
	public AVClass priv_class;
	public interface init_callback extends Callback {
		int apply(AVFilterContext ctx, Pointer args);
	};
	public interface uninit_callback extends Callback {
		void apply(AVFilterContext ctx);
	};
	public interface query_formats_callback extends Callback {
		int apply(AVFilterContext AVFilterContextPtr1);
	};
	public interface process_command_callback extends Callback {
		int apply(AVFilterContext AVFilterContextPtr1, Pointer cmd, Pointer arg, Pointer res, int res_len, int flags);
	};
	public interface init_opaque_callback extends Callback {
		int apply(AVFilterContext ctx, Pointer args, Pointer opaque);
	};
	public AVFilter() {
		super();
	}
	protected List<? > getFieldOrder() {
		return Arrays.asList("name", "description", "inputs", "outputs", "init", "uninit", "query_formats", "priv_size", "process_command", "init_opaque", "priv_class");
	}
	public static class ByReference extends AVFilter implements Structure.ByReference {
		
	};
	public static class ByValue extends AVFilter implements Structure.ByValue {
		
	};
}
