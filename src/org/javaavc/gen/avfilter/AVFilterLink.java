package org.javaavc.gen.avfilter;
import com.sun.jna.Structure;
import com.sun.jna.ptr.PointerByReference;
import java.util.Arrays;
import java.util.List;
import org.javaavc.gen.avfilter.LibavfilterLibrary.AVFilterChannelLayouts;
import org.javaavc.gen.avfilter.LibavfilterLibrary.AVFilterGraph;
import org.javaavc.gen.avfilter.LibavfilterLibrary.AVFilterPool;
import org.javaavc.gen.avfilter.LibavfilterLibrary.AVMediaType;
/**
 * A link between two filters. This contains pointers to the source and<br>
 * destination filters between which this link exists, and the indexes of<br>
 * the pads involved. In addition, this link also contains the parameters<br>
 * which have been negotiated and agreed upon between the filter, such as<br>
 * image dimensions, format, etc.<br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public abstract class AVFilterLink extends Structure {
	/**
	 * < source filter<br>
	 * C type : AVFilterContext*
	 */
	public org.javaavc.gen.avfilter.AVFilterContext.ByReference src;
	/**
	 * < output pad on the source filter<br>
	 * C type : AVFilterPad*
	 */
	public org.javaavc.gen.avfilter.AVFilterPad.ByReference srcpad;
	/**
	 * < dest filter<br>
	 * C type : AVFilterContext*
	 */
	public org.javaavc.gen.avfilter.AVFilterContext.ByReference dst;
	/**
	 * < input pad on the dest filter<br>
	 * C type : AVFilterPad*
	 */
	public org.javaavc.gen.avfilter.AVFilterPad.ByReference dstpad;
	/**
	 * < filter media type<br>
	 * C type : AVMediaType
	 */
	public AVMediaType type;
	/**
	 * These parameters apply only to video<br>
	 * < agreed upon image width
	 */
	public int w;
	/** < agreed upon image height */
	public int h;
	/**
	 * Conversion Error : struct AVRational {<br>
	 * 	int num; ///< numerator<br>
	 * <br>
	 * 	int den; ///< denominator<br>
	 * <br>
	 * }
	 */
	/**
	 * These parameters apply only to audio<br>
	 * < channel layout of current buffer (see libavutil/channel_layout.h)
	 */
	public long channel_layout;
	/** < samples per second */
	public int sample_rate;
	/** < agreed upon media format */
	public int format;
	/**
	 * Conversion Error : struct AVRational {<br>
	 * 	int num; ///< numerator<br>
	 * <br>
	 * 	int den; ///< denominator<br>
	 * <br>
	 * }
	 */
	/**
	 * Lists of formats and channel layouts supported by the input and output<br>
	 * filters respectively. These lists are used for negotiating the format<br>
	 * to actually be used, which will be loaded into the format and<br>
	 * channel_layout members, above, when chosen.<br>
	 * C type : AVFilterFormats*
	 */
	public PointerByReference in_formats;
	/** C type : AVFilterFormats* */
	public PointerByReference out_formats;
	/**
	 * Lists of channel layouts and sample rates used for automatic<br>
	 * negotiation.<br>
	 * C type : AVFilterFormats*
	 */
	public PointerByReference in_samplerates;
	/** C type : AVFilterFormats* */
	public PointerByReference out_samplerates;
	/** C type : AVFilterChannelLayouts* */
	public AVFilterChannelLayouts in_channel_layouts;
	/** C type : AVFilterChannelLayouts* */
	public AVFilterChannelLayouts out_channel_layouts;
	/**
	 * Audio only, the destination filter sets this to a non-zero value to<br>
	 * request that buffers with the given number of samples should be sent to<br>
	 * it. AVFilterPad.needs_fifo must also be set on the corresponding input<br>
	 * pad.<br>
	 * Last buffer before EOF will be padded with silence.
	 */
	public int request_samples;
	/**
	 * stage of the initialization of the link properties (dimensions, etc)<br>
	 * @see init_state_enum<br>
	 * C type : init_state_enum
	 */
	public int init_state;
	/** C type : AVFilterPool* */
	public AVFilterPool pool;
	/**
	 * Graph the filter belongs to.<br>
	 * C type : AVFilterGraph*
	 */
	public AVFilterGraph graph;
	/**
	 * Current timestamp of the link, as defined by the most recent<br>
	 * frame(s), in AV_TIME_BASE units.
	 */
	public long current_pts;
	/** Index in the age array. */
	public int age_index;
	/**
	 * Conversion Error : struct AVRational {<br>
	 * 	int num; ///< numerator<br>
	 * <br>
	 * 	int den; ///< denominator<br>
	 * <br>
	 * }
	 */
	/**
	 * Buffer partially filled with samples to achieve a fixed/minimum size.<br>
	 * C type : AVFilterBufferRef*
	 */
	public org.javaavc.gen.avfilter.AVFilterBufferRef.ByReference partial_buf;
	/**
	 * Size of the partial buffer to allocate.<br>
	 * Must be between min_samples and max_samples.
	 */
	public int partial_buf_size;
	/**
	 * Minimum number of samples to filter at once. If filter_frame() is<br>
	 * called with fewer samples, it will accumulate them in partial_buf.<br>
	 * This field and the related ones must not be changed after filtering<br>
	 * has started.<br>
	 * If 0, all related fields are ignored.
	 */
	public int min_samples;
	/**
	 * Maximum number of samples to filter at once. If filter_frame() is<br>
	 * called with more samples, it will split them.
	 */
	public int max_samples;
	/**
	 * The buffer reference currently being received across the link by the<br>
	 * destination filter. This is used internally by the filter system to<br>
	 * allow automatic copying of buffers which do not have sufficient<br>
	 * permissions for the destination. This should not be accessed directly<br>
	 * by the filters.<br>
	 * C type : AVFilterBufferRef*
	 */
	public org.javaavc.gen.avfilter.AVFilterBufferRef.ByReference cur_buf_copy;
	/**
	 * True if the link is closed.<br>
	 * If set, all attemps of start_frame, filter_frame or request_frame<br>
	 * will fail with AVERROR_EOF, and if necessary the reference will be<br>
	 * destroyed.<br>
	 * If request_frame returns AVERROR_EOF, this flag is set on the<br>
	 * corresponding link.<br>
	 * It can be set also be set by either the source or the destination<br>
	 * filter.
	 */
	public int closed;
	/** Number of channels. */
	public int channels;
	/** enum values */
	public static interface init_state_enum {
		/** < not started */
		public static final int AVLINK_UNINIT = 0;
		/** < started, but incomplete */
		public static final int AVLINK_STARTINIT = 1;
		/** < complete */
		public static final int AVLINK_INIT = 2;
	};
	public AVFilterLink() {
		super();
	}
	protected List<? > getFieldOrder() {
		return Arrays.asList("src", "srcpad", "dst", "dstpad", "type", "w", "h", "channel_layout", "sample_rate", "format", "in_formats", "out_formats", "in_samplerates", "out_samplerates", "in_channel_layouts", "out_channel_layouts", "request_samples", "init_state", "pool", "graph", "current_pts", "age_index", "partial_buf", "partial_buf_size", "min_samples", "max_samples", "cur_buf_copy", "closed", "channels");
	}
	public static abstract class ByReference extends AVFilterLink implements Structure.ByReference {
		
	};
	public static abstract class ByValue extends AVFilterLink implements Structure.ByValue {
		
	};
}
